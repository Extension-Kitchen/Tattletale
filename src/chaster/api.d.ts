/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/files/upload": {
    /**
     * Upload attachments
     * @description Upload attachments and get an attachment token to be used in messaging and posts
     *
     * The attachment token expires after one hour.
     */
    post: operations["StorageController_uploadFiles"];
  };
  "/files/{fileKey}": {
    /** Find a file */
    get: operations["StorageController_getFileFromKey"];
  };
  "/reports": {
    /**
     * Create a report
     * @description Create a report
     */
    post: operations["ReportCreationController_createReport"];
  };
  "/locks/shared-locks": {
    /**
     * Find all user shared locks
     * @deprecated
     * @description Use GET /shared-locks instead
     */
    get: operations["LegacySharedLockController_DEPRECATED_findAll"];
    /**
     * Create a shared lock
     * @deprecated
     * @description Use POST /shared-locks
     */
    post: operations["SharedLockController_DEPRECATED_create"];
  };
  "/locks/shared-locks/{sharedLockId}": {
    /**
     * Find a shared lock by id
     * @deprecated
     * @description Use GET /shared-locks/:sharedLockId instead
     */
    get: operations["LegacySharedLockController_DEPRECATED_findOne"];
    /**
     * Update a shared lock
     * @deprecated
     * @description Use PUT /shared-locks/:sharedLockId
     */
    put: operations["SharedLockController_DEPRECATED_update"];
  };
  "/locks/shared-locks/{sharedLockId}/archive": {
    /**
     * Archive a shared lock
     * @deprecated
     * @description Use PATCH /shared-locks/:sharedLockId/archive instead
     */
    post: operations["LegacySharedLockController_DEPRECATED_archive"];
  };
  "/locks": {
    /**
     * Get user locks
     * @description Returns a list of all user locks
     *
     * By default, only active locks are returned.
     */
    get: operations["LockController_findAll"];
    /**
     * Create a lock
     * @description Creates a personal lock. To create a lock, you must first create
     * a combination by using the combination endpoints, and then provide its identifier.
     */
    post: operations["LockCreationController_create"];
  };
  "/locks/{lockId}": {
    /**
     * Get a lock by id
     * @description Returns a lock by id
     */
    get: operations["LockController_findOne"];
  };
  "/locks/{lockId}/archive": {
    /**
     * Archive a lock
     * @description Archives a lock as a wearer. A wearer can archive its own lock:
     * <ul>
     * <li>If the lock is running (status `locked`), the lock will become deserted (status `deserted`),
     * with no possibility of going back.</li>
     * <li>If the lock is unlocked, the lock will simply be archived.</li>
     * </ul>
     */
    post: operations["LockController_archive"];
  };
  "/locks/{lockId}/archive/keyholder": {
    /**
     * Archive a lock as a keyholder
     * @description Archives a lock as a keyholder. Keyholders can use this endpoint to archive unlocked locks.
     */
    post: operations["LockController_archiveKeyholder"];
  };
  "/locks/{lockId}/update-time": {
    /**
     * Update lock duration
     * @description Adds or removes duration to a lock. Keyholders can add or remove time, while wearers can only add time.
     */
    post: operations["LockController_updateTime"];
  };
  "/locks/{lockId}/freeze": {
    /**
     * Freeze a lock
     * @description Freezes a lock. Keyholders can use this endpoint to freeze wearer's locks.
     */
    post: operations["LockController_setFreeze"];
  };
  "/locks/{lockId}/unlock": {
    /**
     * Unlock a lock
     * @description Unlocks a lock. For wearers, the lock must respect certain constraints so that it can be unlocked.
     */
    post: operations["LockController_unlock"];
  };
  "/locks/{lockId}/convert-to-self-lock": {
    /**
     * Convert a lock to a self lock
     * @description Converts a lock to a self lock. Only the wearer can convert a lock to a self lock.
     */
    post: operations["LockController_convertToSelfLock"];
  };
  "/locks/{lockId}/settings": {
    /**
     * Update lock settings
     * @description Update locks settings. Only the keyholder can update lock settings.
     */
    post: operations["LockController_setSettings"];
  };
  "/locks/{lockId}/max-limit-date": {
    /**
     * Increase the max limit date
     * @description Increase the max limit date. Only the wearer can increase the limit.
     */
    post: operations["LockController_setMaxLimitDate"];
  };
  "/locks/{lockId}/trust-keyholder": {
    /**
     * Trust the keyholder
     * @description Trust the keyholder. Only the wearer can trust the keyholder.
     */
    post: operations["LockController_trustKeyholder"];
  };
  "/locks/{lockId}/combination": {
    /**
     * Find a lock combination
     * @description Finds a lock combination
     */
    get: operations["LockController_combination"];
  };
  "/locks/{lockId}/history": {
    /**
     * Return lock history
     * @description Returns a list of action logs
     */
    post: operations["LockController_getLockHistory"];
  };
  "/locks/{lockId}/is-test-lock": {
    /**
     * Set an archived lock as a test lock
     * @description Set an archived lock as a test lock
     */
    put: operations["LockController_setAsTestLock"];
  };
  "/locks/user/{userId}": {
    /**
     * Return the public locks of a user
     * @description Returns the public locks of a user
     */
    get: operations["LockVisitorController_getUserLocks"];
  };
  "/combinations/image": {
    /**
     * Upload a combination image
     * @description Uploads an image and stores the combination. Once the image is uploaded,
     * it cannot be recovered without being associated with a lock. To retrieve
     * the combination, refer to the endpoint `/locks/{lockId}/combination` to
     * get the image URL.
     *
     * If the combination is not associated with a lock, it expires after one hour.
     */
    post: operations["CombinationController_uploadImage"];
  };
  "/combinations/code": {
    /**
     * Create a code combination
     * @description Creates and stores the code combination. Once the code is sent, it cannot
     * be recovered without being associated with a lock. To retrieve the
     * combination, refer to the endpoint `/locks/{lockId}/combination` to get
     * the code.
     *
     * If the combination is not associated with a lock, it expires after one hour.
     */
    post: operations["CombinationController_createCode"];
  };
  "/users/profile/by-id/{userId}": {
    /** Find a user by id */
    get: operations["ProfileController_getUserById"];
  };
  "/users/profile/{username}": {
    /** Find a user profile */
    get: operations["ProfileController_getUser"];
  };
  "/users/profile/{username}/details": {
    /** Find a user profile with details */
    get: operations["ProfileController_getUserProfile"];
  };
  "/extensions": {
    /**
     * Get the list of extensions
     * @description Returns the list of all extensions in memory
     */
    get: operations["ExtensionListController_getExtensions"];
  };
  "/public-locks/{sharedLockId}": {
    /**
     * Find a public shared lock
     * @description Finds a public shared lock
     */
    get: operations["PublicLockController_findOne"];
  };
  "/public-locks/images/{sharedLockId}": {
    /**
     * Generate a shared lock image
     * @description Generates an image illustrating the shared lock, to publish it on forums or social networks.
     */
    get: operations["PublicLockController_getSharedLockImage"];
  };
  "/public-locks/search": {
    /**
     * Search for locks
     * @description Search for locks
     */
    post: operations["PublicLockController_search"];
  };
  "/explore/categories": {
    /**
     * Find Explore page locks
     * @description Returns the locks of the Explore page
     */
    get: operations["PublicLockExploreController_findAll"];
  };
  "/blocks": {
    /**
     * Find blocked users
     * @description Find blocked users
     */
    get: operations["BlockController_findBlocks"];
    /**
     * Block user
     * @description Block user
     */
    post: operations["BlockController_blockUser"];
  };
  "/blocks/block-interaction/{targetUserId}": {
    /**
     * Find block interaction with another user
     * @description Find block interaction with another user
     */
    get: operations["BlockController_getBlockInteraction"];
  };
  "/blocks/unblock": {
    /**
     * Unblock user
     * @description Unblock user
     */
    post: operations["BlockController_unblockUser"];
  };
  "/session-offer/lock/{lockId}": {
    /**
     * Create a keyholding offer
     * @description Allows the wearer to send a keyholding request to another user.
     */
    post: operations["SessionOfferController_createKeyholdingOffer"];
  };
  "/session-offer/token/{offerToken}/accept": {
    /**
     * Accept a keyholding request
     * @description Accepts a keyholding request from a wearer. By accepting the request, you will become the keyholder. The `offerToken` parameter can be found in the `LockForPublic` object, if the user has enabled this option when creating the lock.
     */
    get: operations["SessionOfferController_acceptKeyholdingRequest"];
  };
  "/session-offer/lock/{lockId}/status": {
    /**
     * Return a list of keyholding offers
     * @description Returns a list of keyholding offers
     */
    get: operations["SessionOfferController_getOfferRequestStatus"];
  };
  "/session-offer/token/{offerToken}": {
    /**
     * Retrive public information of a lock
     * @description Retrieves public information of the lock for the visitor who received a keyholding request link
     */
    get: operations["SessionOfferController_getLockKeyholdingRequest"];
  };
  "/session-offer/{sessionRequestId}": {
    /**
     * Accept or reject a keyholding offer from a wearer
     * @description Accepts or reject a keyholding offer sent directly by a wearer
     */
    post: operations["SessionOfferController_validateOfferRequest"];
  };
  "/session-offer/{sessionRequestId}/archive": {
    /**
     * Archive a keyholding offer
     * @description Archives a keyholding offer. If the offer is pending, it cancels the keyholding offer.
     */
    get: operations["SessionOfferController_archiveKeyholdingOffer"];
  };
  "/session-offer/requests": {
    /**
     * Return keyholding offers from wearers
     * @description Returns keyholding offers from wearers
     */
    get: operations["SessionOfferController_getKeyholderRequests"];
  };
  "/users/badge/count": {
    /**
     * Get the user badge count
     * @description Returns the user badge count
     */
    get: operations["UserBadgeController_getUserBadgeCount"];
  };
  "/conversations": {
    /**
     * Find a list of conversations
     * @description Finds a list of conversations
     */
    get: operations["MessagingController_getConversations"];
    /**
     * Create a conversation
     * @description Creates a conversation
     */
    post: operations["MessagingController_createConversation"];
  };
  "/conversations/by-user/{userId}": {
    /**
     * Find conversation by user id
     * @description Finds a conversation by user id
     */
    get: operations["MessagingController_getConversationByUserId"];
  };
  "/conversations/{conversationId}": {
    /**
     * Find a conversation
     * @description Finds a conversation
     */
    get: operations["MessagingController_getConversation"];
    /**
     * Add a new message to a conversation
     * @description Updates a conversation
     */
    post: operations["MessagingController_sendMessage"];
  };
  "/conversations/{conversationId}/status": {
    /**
     * Set a conversation status
     * @description Updates a conversation status
     */
    put: operations["MessagingController_setConversationStatus"];
  };
  "/conversations/{conversationId}/unread": {
    /**
     * Set a conversation unread status
     * @description Updates a conversation unread status
     */
    put: operations["MessagingController_setConversationUnread"];
  };
  "/conversations/{conversationId}/messages": {
    /**
     * Find messages in a conversation
     * @description Finds messages in a conversation
     */
    get: operations["MessagingController_getMessages"];
  };
  "/messaging/ignored-users": {
    get: operations["IgnoredUserController_findIgnoredUsers"];
  };
  "/locks/{lockId}/extensions/{extensionId}": {
    /** Get information from an extension for a given lock */
    get: operations["LockExtensionController_getLockInfoFromExtension"];
  };
  "/locks/{lockId}/extensions/{extensionId}/action": {
    /**
     * Trigger an action for a lock extension
     * @description Triggers an action in a lock extension
     */
    post: operations["LockExtensionController_triggerAction"];
  };
  "/extensions/temporary-opening/{lockId}/combination": {
    /**
     * Get a lock combination
     * @description Returns the lock combination
     *
     * This endpoint only works if the lock is temporarily unlocked by the temporary opening extension
     */
    get: operations["TemporaryOpeningExtensionController_getCombination"];
    /**
     * Set the new combination
     * @description Updates the lock combination
     *
     * This endpoint only works if the lock is temporarily unlocked by the temporary opening extension
     */
    post: operations["TemporaryOpeningExtensionController_setCombination"];
  };
  "/extensions/temporary-opening/{lockId}/action-log/{actionLogId}/combination": {
    /**
     * Find a combination from an action log
     * @description Finds a lock combination from a previous temporary opening
     */
    get: operations["TemporaryOpeningExtensionController_getCombinationFromHistoryEntry"];
  };
  "/community-event/categories": {
    /** Get community event categories */
    get: operations["CommunityEventController_getCategories"];
  };
  "/community-event/details": {
    /** Get community event task details for a given day */
    post: operations["CommunityEventController_getPeriodDetails"];
  };
  "/locks/{lockId}/extensions": {
    /**
     * Edit lock extensions
     * @description Edit extensions for a given lock.
     *
     * Keyholders can edit extensions if the lock is trusted by the wearer.
     */
    post: operations["LockCreationController_setLockExtensions"];
  };
  "/public-locks/{sharedLockId}/create-lock": {
    /**
     * Create a lock from a shared lock
     * @description Creates a lock from a shared lock. To create a lock, you must first
     * create a combination and then provide its identifier.
     */
    post: operations["LockCreationController_createLockFromSharedLock"];
  };
  "/api/developers/extensions": {
    /** Return a list of extensions */
    get: operations["PartnerExtensionController_findAll"];
    /** Create an extension */
    post: operations["PartnerExtensionController_create"];
  };
  "/api/developers/extensions/{extensionId}": {
    /** Find an extension */
    get: operations["PartnerExtensionController_findOne"];
    /** Update an extension */
    put: operations["PartnerExtensionController_update"];
    /** Delete an extension */
    delete: operations["PartnerExtensionController_delete"];
  };
  "/api/extensions/sessions/{sessionId}": {
    /** Retrieve information from an extension lock session */
    get: operations["PartnerActionsController_getExtensionSession"];
    /**
     * Update partial information for an extension lock session
     * @description Update partial information for an extension lock session. All fields are optional.
     * If you provide a value for a field, the content of the whole field is replaced.
     * For example, if you provide a `config` object, the whole object is replaced by
     * the payload received. If you only need to update one field in your object, make
     * sure to send the whole object back.
     * If you don't provide a field, it will be unchanged.
     */
    patch: operations["PartnerActionsController_patchExtensionSession"];
  };
  "/api/extensions/sessions/{sessionId}/action": {
    /** Run an action on the lock */
    post: operations["PartnerActionsController_doAction"];
  };
  "/api/extensions/sessions/{sessionId}/logs/search": {
    /** List log entries for an extension lock session */
    post: operations["PartnerActionsController_getLogs"];
  };
  "/api/extensions/sessions/{sessionId}/metadata": {
    /**
     * Update metadata for an extension lock session
     * @deprecated
     * @description Deprecated, please use PATCH /api/extensions/sessions/{sessionId}
     */
    put: operations["PartnerActionsController_setMetadata"];
  };
  "/api/extensions/sessions/search": {
    /**
     * Search for extension sessions
     * @description Search for extension sessions
     */
    post: operations["PartnerSessionController_getSessions"];
  };
  "/api/extensions/sessions/{sessionId}/regular-actions": {
    /** Get submitted regular actions */
    get: operations["SessionRegularActionController_getRegularActions"];
    /** Submit a regular action on the lock */
    post: operations["SessionRegularActionController_submitRegularAction"];
  };
  "/api/extensions/sessions/{sessionId}/logs/custom": {
    /** Create a custom log entry for an extension lock session */
    post: operations["PartnerLogController_logCustomAction"];
  };
  "/api/extensions/sessions/{sessionId}/data": {
    /**
     * Set session custom data
     * @deprecated
     * @description Deprecated, please use PATCH /api/extensions/sessions/{sessionId}
     */
    put: operations["SessionDataController_setData"];
  };
  "/api/extensions/configurations/{token}": {
    /**
     * Retrieve the extension configuration from a configuration token.
     *
     *       The configuration token is passed in hash parameters of your configuration page.
     */
    get: operations["PartnerConfigurationController_getConfiguration"];
    /**
     * Update the extension configuration from a configuration token.
     *
     *       The configuration token is passed in hash parameters of your configuration page.
     */
    put: operations["PartnerConfigurationController_updateConfiguration"];
  };
  "/settings": {
    /** Get app settings */
    get: operations["SettingsController_getAppSettings"];
  };
  "/api/extensions/auth/sessions/{token}": {
    /** Get a session authorization */
    get: operations["PartnerMainAuthorizationController_getSessionAuth"];
  };
  "/auth/profile/update": {
    /** Update profile from the authentication server */
    get: operations["AuthMeController_getUpdatedProfile"];
  };
  "/auth/profile": {
    /** Get logged user information */
    get: operations["AuthMeController_me"];
  };
  "/users/search/by-username": {
    /** Search a user by its username */
    post: operations["UserSearchController_searchByUsername"];
  };
  "/users/search/by-discord-id/{discordId}": {
    /** Search a user by its Discord id */
    get: operations["UserSearchController_getUserByDiscordId"];
  };
  "/keyholder/locks/search": {
    /**
     * Search locked users
     * @description Search locked users
     */
    post: operations["KeyholderController_searchLocks"];
  };
  "/shared-locks/{sharedLockId}/partner-extensions/{partnerExtensionId}/partner-configurations": {
    /** Create a partner configuration from a shared lock extension configuration */
    post: operations["PartnerConfigurationCreationController_createSharedLockPartnerConfiguration"];
  };
  "/locks/{lockId}/partner-extensions/{partnerExtensionId}/partner-configurations": {
    /** Create a partner configuration from a lock extension configuration */
    post: operations["PartnerConfigurationCreationController_createLockPartnerConfiguration"];
  };
  "/partner-extensions/{partnerExtensionId}/partner-configurations": {
    /** Create a partner configuration with the default configuration */
    post: operations["PartnerConfigurationCreationController_createPartnerConfiguration"];
  };
  "/extensions/verification-picture/{lockId}/submit": {
    /**
     * Submit a verification picture
     * @description Uploads a new verification picture
     *
     * A user can upload a picture only if there is an existing request.
     */
    post: operations["VerificationPictureController_submitPicture"];
  };
  "/locks/{lockId}/verification-pictures": {
    /** Get the history of verification pictures */
    get: operations["VerificationPictureController_getVerificationPictures"];
  };
  "/shared-locks": {
    /**
     * Find all user shared locks
     * @description Returns a list of all user shared locks
     */
    get: operations["SharedLockController_findAll"];
    /**
     * Create a shared lock
     * @description Creates a shared lock
     */
    post: operations["SharedLockController_create"];
  };
  "/shared-locks/{sharedLockId}": {
    /**
     * Find a shared lock by id
     * @description Finds a shared lock by id
     */
    get: operations["SharedLockController_findOne"];
    /**
     * Update a shared lock
     * @description Updates a shared lock
     */
    put: operations["SharedLockController_update"];
  };
  "/shared-locks/{sharedLockId}/archive": {
    /**
     * Archive a shared lock
     * @description Archives a shared lock
     */
    post: operations["SharedLockController_archive"];
  };
  "/shared-lock-tags": {
    /** Find all shared lock tags */
    get: operations["SharedLockTagController_findAllTags"];
  };
  "/shared-lock-tags/suggested": {
    /** Find suggested shared lock tags */
    post: operations["SharedLockTagController_findSuggestedTags"];
  };
  "/shared-locks/{sharedLockId}/favorite": {
    /** Check if the shared lock is in user favorites */
    get: operations["SharedLockFavoriteController_isFavorite"];
    /** Set a shared lock as favorite */
    put: operations["SharedLockFavoriteController_setFavorite"];
    /** Remove a favorite shared lock */
    delete: operations["SharedLockFavoriteController_removeFavorite"];
  };
  "/favorites/shared-locks": {
    /** Get user favorite shared locks */
    post: operations["SharedLockFavoritesController_getFavoriteSharedLocks"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    UploadFilesDto: {
      /** @description The files to upload */
      files: string[];
      /**
       * @description The target storage
       * @enum {string}
       */
      type: "messaging" | "community_event_challenge";
    };
    UploadFilesRepDto: {
      /**
       * @description The attachment token
       *
       * It can be used in messaging, post and other endpoints that support
       * attachments
       */
      token: string;
    };
    GetFileFromKeyRepDto: {
      /** @description The file url */
      url: string;
    };
    CreateMessageReportItemDto: {
      /**
       * @description The report type
       * Equals to `message`
       * @enum {string}
       */
      type: "message";
      /** @description The message id */
      messageId: string;
    };
    CreatePostReportItemDto: {
      /**
       * @description The report type
       * Equals to `post`
       * @enum {string}
       */
      type: "post";
      /** @description The post id */
      postId: string;
    };
    CreateSharedLockReportItemDto: {
      /**
       * @description The report type
       * Equals to `post`
       * @enum {string}
       */
      type: "shared_lock";
      /** @description The shared lock id */
      sharedLockId: string;
    };
    CreateUserReportItemDto: {
      /**
       * @description The report type
       * Equals to `user`
       * @enum {string}
       */
      type: "user";
      /** @description The user id */
      userId: string;
    };
    CreateReportDto: {
      /** @description The content to report */
      target: components["schemas"]["CreateMessageReportItemDto"] | components["schemas"]["CreatePostReportItemDto"] | components["schemas"]["CreateSharedLockReportItemDto"] | components["schemas"]["CreateUserReportItemDto"];
      /**
       * @description The reason of the report
       * @enum {string}
       */
      reason: "harassment" | "suicide_self_injury" | "inappropriate_content" | "hate_speech" | "unsolicited_content" | "unauthorized_financial_activity" | "other";
      /** @description An optional message */
      message?: string;
    };
    /** @enum {string} */
    SharedLockDurationModeEnum: "duration" | "date";
    /** @enum {string} */
    SharedLockReasonForPublicHideEnum: "user_not_findom" | "other";
    /** @enum {string} */
    SexualOrientationEnum: "Unspecified" | "Straight" | "Gay" | "Lesbian" | "Bisexual" | "Pansexual" | "Aromantic" | "Androsexual" | "Asexual" | "Demisexual" | "Gynesexual" | "Polysexual" | "Queer" | "Skoliosexual";
    /** @enum {string} */
    UserRoleEnum: "keyholder" | "wearer" | "switch" | "unspecified";
    /** @enum {string} */
    FeatureSwitchEnum: "partner_extensions" | "age_verification" | "block_registration_with_disposable_email" | "block_registration_with_vpn" | "tags_for_shared_locks" | "push_notifications" | "block_users" | "update_random_events_with_new_model" | "other" | "dummy_1" | "dummy_2" | "dummy_3";
    UserMetadata: {
      locktober2020Points: number;
      locktober2021Points: number;
      chastityMonth2022Points: number;
      locktober2022Points: number;
      locktober2023Points: number;
    };
    UserForPublic: {
      /** @description The sexual orientation */
      sexualOrientation: components["schemas"]["SexualOrientationEnum"];
      /** @description The role */
      role: components["schemas"]["UserRoleEnum"];
      /** @description Enabled features */
      features: components["schemas"]["FeatureSwitchEnum"][];
      /** @description The user id */
      _id: string;
      /** @description The username */
      username: string;
      /** @description Whether the user has a Premium subscription */
      isPremium: boolean;
      /** @description The profile description */
      description: string;
      /** @description The location */
      location: string;
      /** @description The gender */
      gender: string;
      /** @description The age */
      age: number | null;
      /** @description Whether the user is a findom */
      isFindom: boolean;
      /** @description The avatar URL */
      avatarUrl: string;
      /** @description Whether the user is online */
      online: boolean;
      /** @description User last seen, in seconds */
      lastSeen: number | null;
      /** @description Whether the user is an admin */
      isAdmin: boolean;
      /** @description Whether the user is a moderator */
      isModerator: boolean;
      /** @description User metadata */
      metadata: components["schemas"]["UserMetadata"];
      /** @description User full location */
      fullLocation: string;
      /** @description The Discord ID */
      discordId: string | null;
      /** @description The Discord username */
      discordUsername: string | null;
      /** @description Whether the user is disabled */
      isDisabled: boolean;
      /** @description Whether the user is suspended by the Chaster team */
      isSuspended: boolean;
      /** @description Joined date (year and month, YYYY-MM) */
      joinedAt: string;
      /** @description Whether the user is a new member */
      isNewMember: boolean;
      /** @description Whether the user is suspended or disabled */
      isSuspendedOrDisabled: boolean;
    };
    UnsplashPhoto: {
      id: string;
      username: string;
      name: string;
      url: string;
    };
    /** @enum {string} */
    ExtensionModeEnum: "cumulative" | "non_cumulative" | "turn" | "unlimited";
    ExtensionConfigForPublic: {
      /** @description The extension slug. */
      slug: string;
      /** @description The extension configuration. */
      config: Record<string, never>;
      mode: components["schemas"]["ExtensionModeEnum"];
      name: string;
      textConfig?: string;
      regularity: number;
    };
    /** @enum {string} */
    LockStatusEnum: "locked" | "unlocked" | "deserted";
    /** @enum {string} */
    KeyholderUnavailableEnum: "suspended" | "disabled" | "inactive";
    SharedLockForPublic: {
      /** @description Duration mode */
      durationMode: components["schemas"]["SharedLockDurationModeEnum"];
      reasonForPublicHide: components["schemas"]["SharedLockReasonForPublicHideEnum"];
      /** @description The shared lock id */
      _id: string;
      /** @description The minimum duration, in seconds */
      minDuration: number;
      /** @description The maximum duration, in seconds */
      maxDuration: number;
      /** @description The calculated max limit duration */
      calculatedMaxLimitDuration: number | null;
      /** @description The creator */
      user: components["schemas"]["UserForPublic"];
      /** @description The Unsplash photo */
      unsplashPhoto: components["schemas"]["UnsplashPhoto"] | null;
      /** @description Extension configurations */
      extensions: components["schemas"]["ExtensionConfigForPublic"][];
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string | null;
      /** @description Deleted at */
      deletedAt: string | null;
      /** @description Archived at */
      archivedAt: string | null;
      /**
       * @description List of locks
       *
       * Only returned in shared locks endpoints
       */
      locks?: components["schemas"]["LockForPublic"][];
      /** @description Whether the lock requires a password */
      requirePassword: boolean;
      /** @description Password */
      password: string | null;
      /**
       * @description The maximum duration of the lock, in seconds
       *
       * After this duration, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDuration: number | null;
      /**
       * Format: date-time
       * @description The minimum date
       */
      minDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date
       */
      maxDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date of the lock
       *
       * After this date, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDate: string | null;
      /** @description Whether the remaining time should be displayed to the wearer */
      displayRemainingTime: boolean;
      /** @description Whether the lock is limited in time */
      limitLockTime: boolean;
      /** @description The number of maximum locked users for this shared lock */
      maxLockedUsers: number | null;
      /** @description Whether the lock is public */
      isPublic: boolean;
      /**
       * @description Whether the shared lock requires contact from wearer
       *
       * Displayed for information purposes only on the lock page
       */
      requireContact: boolean;
      /** @description The name */
      name: string;
      /** @description The description */
      description: string;
      /** @description The tags */
      tags: string[];
      /** @description Whether the time information should be hidden from the history */
      hideTimeLogs: boolean;
      /** @description Whether the lock is findom */
      isFindom: boolean;
      /**
       * Format: date-time
       * @description Last saved at
       */
      lastSavedAt: string;
    };
    ExtensionPartyForPublic: {
      /** @description The extension slug. */
      slug: string;
      /** @description The extension configuration. */
      config: Record<string, never>;
      _id: string;
      /** @description This is the name of the extension, which will be displayed to other users in the list of extensions, and in the description of locks. */
      displayName: string;
      /** @description This is the description of your extension, it is a paragraph explaining how your extension works, and what its purpose is. */
      summary: string;
      /** @description This is the subtitle of the extension, it is a short sentence explaining the concept of your extension, and will be displayed in the list of extensions. */
      subtitle: string;
      /**
       * @description The icon you choose must be one of the regular icons available on FontAwesome 5, which you can find list here. The icon will be displayed in the list of extensions.
       *
       * Contact us if you want to change the icon of your extension.
       */
      icon: string;
      /**
       * @description An extension can offer different modes, depending on the way it works and the actions to be performed. An action is a user interaction, for example in Chaster extensions, spinning the wheel of fortune, assigning a task, or checking in. The frequency of the actions can be defined and limited according to the mode chosen by the user among the modes offered by the extension.
       *
       * More information: https://docs.chaster.app/api/extensions-api/configuration#available-modes
       * @enum {string}
       */
      mode: "cumulative" | "non_cumulative" | "turn" | "unlimited";
      userData: Record<string, never>;
      /** @description The regularity displayed in the configuration, if the user chooses the cumulative or non-cumulative mode. If you enable only Unlimited mode, you don't need to fill this parameter. */
      regularity: number;
      /**
       * @description The number of regular actions remaining. If the mode is Unlimited, it returns -1.
       *
       * Use it to display the number of actions remaining to the user, and know when the user can perform a regular action.
       * If the value is 0, the user cannot perform a regular action.
       */
      nbActionsRemaining: number;
      /**
       * @description The date when the next regular action can be performed.
       *
       * Use it to compare the current date with the next action date to know when the user can perform a regular action.
       * If the value is null, the user can perform a regular action.
       * If the mode is Unlimited, it always returns null.
       */
      nextActionDate?: string;
      isPartner: boolean;
      textConfig: string;
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string;
    };
    ExtensionHomeActionWithPartyId: {
      extensionPartyId: string;
      /** @description An identifier that is returned to the extension when the user navigates to the extension page. */
      slug: string;
      /** @description The title displayed on the list item for the action. */
      title: string;
      /** @description The description displayed on the list item for the action. */
      description: string;
      /** @description The icon associated with the action, which must be one of the valid FontAwesome 5 icons. */
      icon: string;
      /** @description Displays a small badge on the list item, useful for indicating notifications or counts associated with the action (e.g., the number of tasks to do or remaining actions in the extension). */
      badge?: string;
    };
    ReasonPreventingUnlocking: {
      reason: string;
      icon: string;
    };
    VerificationPictureItem: {
      imageKey: string;
      /** Format: date-time */
      submittedAt: string;
      verificationCode: string;
      filename?: string;
      peerVerificationId?: string;
    };
    LockForPublic: {
      /** @description The status */
      status: components["schemas"]["LockStatusEnum"];
      /**
       * @description Whether the keyholder is unavailable
       * Only available for the wearer
       */
      keyholderUnavailable?: components["schemas"]["KeyholderUnavailableEnum"];
      /** @description The lock id */
      _id: string;
      /**
       * Format: date-time
       * @description The end date
       */
      endDate: string | null;
      /** @description The lock title */
      title: string;
      /** @description The total duration, since the creation of the lock */
      totalDuration: number;
      /** @description The user */
      user: components["schemas"]["UserForPublic"];
      /** @description The keyholder */
      keyholder: components["schemas"]["UserForPublic"] | null;
      /** @description The shared lock */
      sharedLock: components["schemas"]["SharedLockForPublic"] | null;
      /** @description Whether the wearer is allowed to view the remaining time */
      isAllowedToViewTime: boolean;
      /** @description Whether the lock can be unlocked */
      canBeUnlocked: boolean;
      /** @description Whether the lock can be unlocked because the max limit date has been reached */
      canBeUnlockedByMaxLimitDate: boolean;
      /** @description Whether the lock is frozen */
      isFrozen: boolean;
      /**
       * @description The user role
       * @enum {string}
       */
      role: "keyholder" | "wearer" | "visitor";
      /** @description The extensions */
      extensions: components["schemas"]["ExtensionPartyForPublic"][];
      /** @description The combination */
      combination: string;
      /**
       * @description List of home actions
       * Only available for the wearer
       */
      availableHomeActions?: components["schemas"]["ExtensionHomeActionWithPartyId"][];
      /** @description Reasons preventing unlocking */
      reasonsPreventingUnlocking: components["schemas"]["ReasonPreventingUnlocking"][];
      /** @description Whether the extensions allow unlocking */
      extensionsAllowUnlocking: boolean;
      /** @description The last verification picture */
      lastVerificationPicture: components["schemas"]["VerificationPictureItem"] | null;
      /**
       * Format: date-time
       * @description Created at
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Updated at
       */
      updatedAt: string;
      /**
       * Format: date-time
       * @description The start date
       */
      startDate: string;
      /**
       * Format: date-time
       * @description The minimum initial date configured at creation
       */
      minDate: string;
      /**
       * Format: date-time
       * @description The maximum initial date configured at creation
       */
      maxDate: string;
      /**
       * Format: date-time
       * @description The maximum date of the lock
       *
       * After this date, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDate: string | null;
      /** @description Whether the remaining time is displayed to the wearer */
      displayRemainingTime: boolean;
      /** @description Whether the lock is limited in duration */
      limitLockTime: boolean;
      /**
       * Format: date-time
       * @description Deleted at
       */
      deletedAt: string | null;
      /**
       * Format: date-time
       * @description Unlocked at
       */
      unlockedAt: string | null;
      /**
       * Format: date-time
       * @description Archived at
       */
      archivedAt: string | null;
      /**
       * Format: date-time
       * @description Frozen at
       */
      frozenAt: string | null;
      /**
       * Format: date-time
       * @description Keyholder archived at
       */
      keyholderArchivedAt: string | null;
      /** @description Whether the lock allows session offers */
      allowSessionOffer: boolean;
      /** @description Whether the lock is a test lock and counts in the user stats */
      isTestLock: boolean;
      /** @description The offer token */
      offerToken: string | null;
      /** @description True if the time information should be hidden from the history */
      hideTimeLogs: boolean;
      /** @description Whether the keyholder is trusted */
      trusted: boolean;
    };
    UpdateTimeDto: {
      /**
       * @description The duration to add, in seconds
       *
       * Wearer can only add duration (positive values),
       * unlike keyholders who can add or remove time.
       */
      duration: number;
    };
    SetFreezeDto: {
      /** @description Whether the lock is frozen */
      isFrozen: boolean;
    };
    SetLockSettingsDto: {
      /** @description Whether the remaining time is displayed to the wearer */
      displayRemainingTime?: boolean;
      /** @description Whether the time information should be hidden from the history */
      hideTimeLogs?: boolean;
    };
    IncreaseMaxLimitDateDto: {
      /**
       * Format: date-time
       * @description The new maximum limit date
       */
      maxLimitDate: string;
      /**
       * @description Whether the maximum limit date should be disabled
       * @default false
       */
      disableMaxLimitDate: boolean;
    };
    CombinationForPublic: {
      /**
       * @deprecated
       * @description Use imageFullUrl instead
       */
      imageUrl?: string;
      /** @description The combination id */
      _id: string;
      /** @description The user id */
      user: string;
      /**
       * @description The review status, if the combination requires a manual review
       * from the moderators
       * @enum {string}
       */
      checkStatus: "pending" | "verified" | "failed";
      /**
       * @description The combination type
       * @enum {string}
       */
      type: "image" | "code";
      /** @description The combination code, if the type is `code` */
      code?: string;
      /** @description The combination image, if the type is `image` */
      imageFullUrl?: string;
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string;
      /** @description Whether the combination requires a manual review from the moderators */
      enableManualCheck: boolean;
    };
    GetLockHistoryDto: {
      /** @description If provided, filter by extension slug */
      extension?: string;
      /** @description Limit */
      limit?: number;
      /** @description Offset lastId */
      lastId?: string;
    };
    ActionLogForPublic: {
      /** @description The action log id */
      _id: string;
      /**
       * @description The action log type
       * When comparing the type, make sure to also compare the prefix
       * Read more on https://docs.chaster.app/api/reference/action-logs
       */
      type: string;
      /** @description The action log payload */
      payload: Record<string, never>;
      /** @description The lock id */
      lock: string;
      /**
       * @description The role of the user who performed the action
       * @enum {string}
       */
      role: "user" | "keyholder" | "extension" | "admin";
      /** @description The extension which performed the action */
      extension?: string;
      /**
       * @description The title of the action log
       * The title can contain the string '%USER%', which can be replaced with the user's name
       */
      title: string;
      /**
       * @description The description of the action log
       * The description can contain the string '%USER%', which can be replaced with the user's name
       */
      description: string;
      /** @description The color of the action log */
      color: string | null;
      /**
       * Format: date-time
       * @description Created at
       */
      createdAt: string;
      /** @description The FontAwesome v5 icon of the action log, with the fa prefix */
      icon: string | null;
      /**
       * @description The prefix of the action log
       * For common action logs, the prefix is `default`. Action logs created by a partner extension have their own prefix.
       */
      prefix: string;
      /** @description The user who performed the action */
      user?: components["schemas"]["UserForPublic"];
    };
    GetHistoryRepDto: {
      /** @description List of action logs */
      results: components["schemas"]["ActionLogForPublic"][];
      /** @description Number of total action logs */
      count: number;
      /** @description Has more results */
      hasMore: boolean;
    };
    UploadCombinationImageDto: {
      /**
       * Format: binary
       * @description The combination image
       */
      file: string;
      /** @description Enables the manual combination image check, for Premium users. */
      enableManualCheck?: boolean;
    };
    CreateCodeRepDto: {
      combinationId: string;
    };
    CreateCodeDto: {
      /** @description The code combination */
      code: string;
    };
    UserStatsForPublic: {
      /** @description Number of locks started by the user as a wearer */
      nbStartedLocks: number;
      /** @description Number of locks ended by the user as a wearer */
      nbEndedLocks: number;
      /** @description Total time locked */
      totalTimeLocked: number;
      /** @description Maximum session duration */
      maxTimeLocked: number;
      /** @description Number of locks keyholded */
      keyholderNbLocks: number;
    };
    GetUserAchievementsResponseDto: {
      slug: string;
      granted: boolean;
      progress: number | null;
      total: number | null;
      grantedAt: string | null;
      name: string;
      description: string;
      category: string;
      progressEnabled: boolean;
      hideIfNotGranted: boolean;
    };
    PublicLockJoinRules: {
      canBeJoined: boolean;
      containsPremiumExtension: boolean;
      exceedsExtensionLimit: boolean;
      oneOfExtensionsDisabled: boolean;
    };
    PublicLockForProfilePage: {
      /** @description Duration mode */
      durationMode: components["schemas"]["SharedLockDurationModeEnum"];
      reasonForPublicHide: components["schemas"]["SharedLockReasonForPublicHideEnum"];
      /**
       * @description The maximum duration of the lock, in seconds
       *
       * After this duration, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDuration: number | null;
      /**
       * Format: date-time
       * @description The minimum date
       */
      minDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date
       */
      maxDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date of the lock
       *
       * After this date, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDate: string | null;
      /** @description Whether the remaining time should be displayed to the wearer */
      displayRemainingTime: boolean;
      /** @description Whether the lock is limited in time */
      limitLockTime: boolean;
      /** @description The number of maximum locked users for this shared lock */
      maxLockedUsers: number | null;
      /** @description Whether the lock is public */
      isPublic: boolean;
      /**
       * @description Whether the shared lock requires contact from wearer
       *
       * Displayed for information purposes only on the lock page
       */
      requireContact: boolean;
      /** @description The name */
      name: string;
      /** @description The description */
      description: string;
      /** @description The tags */
      tags: string[];
      /** @description The Unsplash photo */
      unsplashPhoto: components["schemas"]["UnsplashPhoto"] | null;
      /** @description Whether the time information should be hidden from the history */
      hideTimeLogs: boolean;
      /** @description Whether the lock is findom */
      isFindom: boolean;
      /**
       * Format: date-time
       * @description Last saved at
       */
      lastSavedAt: string;
      /** @description The shared lock id */
      _id: string;
      /** @description The calculated max limit duration */
      calculatedMaxLimitDuration: number | null;
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string | null;
      /** @description Deleted at */
      deletedAt: string | null;
      /** @description Archived at */
      archivedAt: string | null;
      /**
       * @description List of locks
       *
       * Only returned in shared locks endpoints
       */
      locks?: components["schemas"]["LockForPublic"][];
      /** @description Whether the lock requires a password */
      requirePassword: boolean;
      minDuration: number;
      maxDuration: number;
      joinRules: components["schemas"]["PublicLockJoinRules"];
    };
    ChastikeyStatsForPublic: {
      _id: string;
      totalLocksManaged: number;
      cumulativeSecondsLocked: number;
      averageTimeLockedInSeconds: number;
      longestCompletedLockInSeconds: number;
      totalNoOfCompletedLocks: number;
      username: string;
      mainRole: string;
    };
    BlockInteraction: {
      blockedByActionUser: boolean;
      blockedByOtherUser: boolean;
      canInteract: boolean;
    };
    ProfileRepDto: {
      user: components["schemas"]["UserForPublic"];
      stats: components["schemas"]["UserStatsForPublic"] | null;
      achievements: components["schemas"]["GetUserAchievementsResponseDto"][];
      sharedLocks: components["schemas"]["PublicLockForProfilePage"][];
      chastikeyStats: components["schemas"]["ChastikeyStatsForPublic"] | null;
      blockInteraction: components["schemas"]["BlockInteraction"];
    };
    ExtensionOwnerForPublic: {
      username: string;
    };
    ExtensionForPublic: {
      /** @description Available modes */
      availableModes: components["schemas"]["ExtensionModeEnum"][];
      /** @description The extension configuration. */
      defaultConfig: Record<string, never>;
      partnerExtensionId: string | null;
      configIframeUrl: string | null;
      isTesting: boolean;
      isPartner: boolean;
      isDevelopedByCommunity: boolean;
      owner: components["schemas"]["ExtensionOwnerForPublic"] | null;
      /** @description The extension subtitle */
      subtitle: string;
      /** @description The extension summary */
      summary: string;
      /** @description The name displayed to the end users */
      displayName: string;
      /** @description The extension icon */
      icon: string;
      /** @description The extension slug */
      slug: string;
      /**
       * @description Default regularity
       * @default 3600
       */
      defaultRegularity: number;
      /**
       * @description TWhether the extension is enabled
       * @default true
       */
      isEnabled: boolean;
      /**
       * @description Whether the extension is only available to Premium users
       * @default false
       */
      isPremium: boolean;
      /**
       * @description Whether the extension is displayed by default in the list
       * @default false
       */
      isFeatured: boolean;
      /**
       * @description Whether the extension is counted in the extensions limit
       * @default true
       */
      isCountedInExtensionsLimit: boolean;
      /**
       * @description Whether the extension has actions
       * @default true
       */
      hasActions: boolean;
    };
    PublicLockForPublic: {
      /** @description Duration mode */
      durationMode: components["schemas"]["SharedLockDurationModeEnum"];
      reasonForPublicHide: components["schemas"]["SharedLockReasonForPublicHideEnum"];
      minDuration: number;
      maxDuration: number;
      joinRules: components["schemas"]["PublicLockJoinRules"];
      /**
       * @description The maximum duration of the lock, in seconds
       *
       * After this duration, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDuration: number | null;
      /**
       * Format: date-time
       * @description The minimum date
       */
      minDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date
       */
      maxDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date of the lock
       *
       * After this date, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDate: string | null;
      /** @description Whether the remaining time should be displayed to the wearer */
      displayRemainingTime: boolean;
      /** @description Whether the lock is limited in time */
      limitLockTime: boolean;
      /** @description The number of maximum locked users for this shared lock */
      maxLockedUsers: number | null;
      /** @description Whether the lock is public */
      isPublic: boolean;
      /**
       * @description Whether the shared lock requires contact from wearer
       *
       * Displayed for information purposes only on the lock page
       */
      requireContact: boolean;
      /** @description The name */
      name: string;
      /** @description The description */
      description: string;
      /** @description The tags */
      tags: string[];
      /** @description The Unsplash photo */
      unsplashPhoto: components["schemas"]["UnsplashPhoto"] | null;
      /** @description Whether the time information should be hidden from the history */
      hideTimeLogs: boolean;
      /** @description Whether the lock is findom */
      isFindom: boolean;
      /**
       * Format: date-time
       * @description Last saved at
       */
      lastSavedAt: string;
      /** @description The shared lock id */
      _id: string;
      /** @description The calculated max limit duration */
      calculatedMaxLimitDuration: number | null;
      /** @description The creator */
      user: components["schemas"]["UserForPublic"];
      /** @description Extension configurations */
      extensions: components["schemas"]["ExtensionConfigForPublic"][];
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string | null;
      /** @description Deleted at */
      deletedAt: string | null;
      /** @description Archived at */
      archivedAt: string | null;
      /**
       * @description List of locks
       *
       * Only returned in shared locks endpoints
       */
      locks?: components["schemas"]["LockForPublic"][];
      /** @description Whether the lock requires a password */
      requirePassword: boolean;
    };
    DurationCriteriaData: {
      minDuration: number;
      maxDuration: number;
    };
    ExtensionCriteriaData: {
      extensions: string[];
      excludedExtensions?: string[];
      /** @default false */
      all: boolean;
    };
    IsFindomCriteriaData: {
      /**
       * @description Whether the lock is findom
       * If true, return only findom locks.
       * If false, return only non-findom locks.
       */
      isFindom: boolean;
    };
    /** @enum {string} */
    SearchableGenderEnum: "Male" | "Female" | "Non-binary" | "Agender" | "Bigender" | "Genderfluid" | "Genderqueer" | "Pangender" | "Two-spirit";
    AgeCriteriaData: {
      /** @description Min age should be greater than 18. */
      minAge: number;
      /**
       * @description Max age should be less than 65.
       * If max age is 65, it means that the user is 65 or older.
       */
      maxAge: number;
    };
    CountryForSearchUsers: {
      countryShortCode: string;
    };
    RegionForSearchUsers: {
      name: string;
    };
    LocationCriteriaData: {
      country: components["schemas"]["CountryForSearchUsers"] | null;
      region: components["schemas"]["RegionForSearchUsers"] | null;
    };
    RoleCriteriaData: {
      wearer: boolean;
      keyholder: boolean;
    };
    SearchUsersCriteria: {
      genders?: components["schemas"]["SearchableGenderEnum"][];
      sexualOrientations?: components["schemas"]["SexualOrientationEnum"][];
      age?: components["schemas"]["AgeCriteriaData"];
      location?: components["schemas"]["LocationCriteriaData"];
      role?: components["schemas"]["RoleCriteriaData"];
      isFindom?: boolean;
      isActive?: boolean;
    };
    SearchPublicLockCriteria: {
      duration?: components["schemas"]["DurationCriteriaData"];
      maxLimitDuration?: components["schemas"]["DurationCriteriaData"];
      extensions?: components["schemas"]["ExtensionCriteriaData"];
      /**
       * @description Whether the lock is findom
       * Unset this field to return both findom and non-findom locks.
       */
      isFindom?: components["schemas"]["IsFindomCriteriaData"];
      /**
       * @description Search locks by user criteria
       * This criteria is only available for authenticated users
       */
      user?: components["schemas"]["SearchUsersCriteria"];
      /** @description Search locks by tags */
      tags?: string[];
      /**
       * @description Whether to match all tags
       * If true, return locks that contain all the tags
       * If false, return locks that contain at least one of the tags
       */
      matchAllTags?: boolean;
      /** @description Search locks by name or description */
      search?: string;
    };
    SearchPublicLockDto: {
      /** @default {} */
      criteria: components["schemas"]["SearchPublicLockCriteria"];
      /** @default 15 */
      limit: number;
      /**
       * @deprecated
       * @description Last id of the last result
       * This field is deprecated, use cursor instead
       */
      lastId?: string;
      /**
       * @description Cursor for pagination
       * Use the cursor provided in the last result to get the next page of results
       */
      cursor?: string;
    };
    PublicLockForSearch: {
      /** @description Duration mode */
      durationMode: components["schemas"]["SharedLockDurationModeEnum"];
      reasonForPublicHide: components["schemas"]["SharedLockReasonForPublicHideEnum"];
      /**
       * @description The maximum duration of the lock, in seconds
       *
       * After this duration, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDuration: number | null;
      /**
       * Format: date-time
       * @description The minimum date
       */
      minDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date
       */
      maxDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date of the lock
       *
       * After this date, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDate: string | null;
      /** @description Whether the remaining time should be displayed to the wearer */
      displayRemainingTime: boolean;
      /** @description Whether the lock is limited in time */
      limitLockTime: boolean;
      /** @description The number of maximum locked users for this shared lock */
      maxLockedUsers: number | null;
      /** @description Whether the lock is public */
      isPublic: boolean;
      /**
       * @description Whether the shared lock requires contact from wearer
       *
       * Displayed for information purposes only on the lock page
       */
      requireContact: boolean;
      /** @description The name */
      name: string;
      /** @description The description */
      description: string;
      /** @description The tags */
      tags: string[];
      /** @description The Unsplash photo */
      unsplashPhoto: components["schemas"]["UnsplashPhoto"] | null;
      /** @description Whether the time information should be hidden from the history */
      hideTimeLogs: boolean;
      /** @description Whether the lock is findom */
      isFindom: boolean;
      /**
       * Format: date-time
       * @description Last saved at
       */
      lastSavedAt: string;
      /** @description The shared lock id */
      _id: string;
      /** @description The calculated max limit duration */
      calculatedMaxLimitDuration: number | null;
      /** @description The creator */
      user: components["schemas"]["UserForPublic"];
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string | null;
      /** @description Deleted at */
      deletedAt: string | null;
      /** @description Archived at */
      archivedAt: string | null;
      /**
       * @description List of locks
       *
       * Only returned in shared locks endpoints
       */
      locks?: components["schemas"]["LockForPublic"][];
      /** @description Whether the lock requires a password */
      requirePassword: boolean;
      minDuration: number;
      maxDuration: number;
      joinRules: components["schemas"]["PublicLockJoinRules"];
    };
    SearchPublicLockRepDto: {
      count: number;
      hasMore: boolean;
      results: components["schemas"]["PublicLockForSearch"][];
      /**
       * @description Cursor for pagination
       * Use this value to get the next page of results
       */
      cursor?: string;
    };
    ExploreCategoryForPublic: {
      _id: string;
      locks: components["schemas"]["PublicLockForSearch"][];
      description: string;
      featured: boolean;
      nbItems: number | null;
      order: number;
      title: string;
      type: string;
    };
    UserForBlock: {
      /** @description The user id */
      _id: string;
      /** @description The username */
      username: string;
      /** @description The avatar URL */
      avatarUrl: string;
    };
    FindBlocksRepDto: {
      results: components["schemas"]["UserForBlock"][];
    };
    BlockUserDto: {
      targetUserId: string;
    };
    UnblockUserDto: {
      targetUserId: string;
    };
    CreateOfferRequestDto: {
      keyholder: string;
    };
    SessionOfferRequestForPublic: {
      keyholder: components["schemas"]["UserForPublic"];
      lock: string;
      /** @enum {string} */
      status: "pending" | "accepted" | "rejected";
      /** Format: date-time */
      validatedAt?: string;
      /** Format: date-time */
      archivedAt?: string;
    };
    ValidateOfferRequestDto: {
      accept: boolean;
    };
    SessionOfferRequestForKeyholder: {
      keyholder: string;
      lock: components["schemas"]["UserForPublic"];
      /** @enum {string} */
      status: "pending" | "accepted" | "rejected";
      /** Format: date-time */
      validatedAt?: string;
      /** Format: date-time */
      archivedAt?: string;
    };
    UserBadgeCount: {
      /** @description Number of message requests */
      pendingMessages: number;
      /** @description Number of messages */
      unreadMessages: number;
      /** @description Number of keyholding requests */
      keyholdingRequests: number;
    };
    LastMessageForPublic: {
      _id: string;
      /** @description The message content */
      message: string;
    };
    ConversationForPublic: {
      /** @description The conversation id */
      _id: string;
      /** @description List of users who are part of the conversation */
      users: components["schemas"]["UserForPublic"][];
      /** @description The last message sent */
      lastMessage?: components["schemas"]["LastMessageForPublic"];
      /** @description Is the conversation unread */
      unread: boolean;
      /**
       * @description Conversation status
       * @enum {string}
       */
      status: "pending" | "approved" | "ignored";
      /**
       * Format: date-time
       * @description Created at
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Last message at
       */
      lastMessageAt: string;
      /** @description Whether the user is part of the conversation */
      isMember: boolean;
      /** @description Whether the sender is banned */
      isSenderBanned: boolean;
      /**
       * @description The conversation type
       * @enum {string}
       */
      type: "private" | "group";
    };
    GetConversationsRepDto: {
      /** @description List of conversations */
      results: components["schemas"]["ConversationForPublic"][];
      /** @description The number of results */
      count: number;
      /** @description Has more */
      hasMore: boolean;
    };
    CreateConversationDto: {
      /** @description List of user ids in the conversation, excluding the logged user */
      users: string[];
      /**
       * @description The conversation type
       *
       * The `group` type is currently not supported.
       * @enum {string}
       */
      type: "private" | "group";
      /**
       * @description The file token
       *
       * Create a file token by using the `/files/upload` endpoint.
       */
      attachments?: string;
      /** @description The message */
      message: string;
      /**
       * @description Nonce
       *
       * If this field is included, it will be returned to the websocket client
       */
      nonce?: string;
    };
    UpdateConversationDto: {
      /**
       * @description The file token
       *
       * Create a file token by using the `/files/upload` endpoint.
       */
      attachments?: string;
      /** @description The message */
      message: string;
      /**
       * @description Nonce
       *
       * If this field is included, it will be returned to the websocket client
       */
      nonce?: string;
    };
    AppFileForPublic: {
      /** @description The file URL */
      url: string;
    };
    MessageForPublic: {
      /** @description The message id */
      _id: string;
      /** @description The sender id */
      user: string;
      /** @description Message attachments */
      attachments: components["schemas"]["AppFileForPublic"][];
      /** @description The conversation id */
      conversation: string;
      /**
       * Format: date-time
       * @description Created at
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Updated at
       */
      updatedAt: string;
      /**
       * @description Nonce
       *
       * Is present only in the return of the websocket during the creation of the
       * message, for the sender.
       */
      nonce?: string;
      /**
       * @description The message type
       * @enum {string}
       */
      type: "message" | "log";
      /** @description The message content */
      message: string;
    };
    SetConversationStatusDto: {
      /**
       * @description The new conversation status
       * @enum {string}
       */
      status: "approved" | "ignored";
    };
    SetConversationUnreadDto: {
      /** @description True if unread */
      unread: boolean;
    };
    GetMessagesRepDto: {
      /** @description List of messages */
      results: components["schemas"]["MessageForPublic"][];
      /** @description The number of results */
      count: number;
      /** @description Has more */
      hasMore: boolean;
    };
    UserForIgnoredConversation: {
      /** @description The user id */
      _id: string;
      /** @description The username */
      username: string;
      /** @description The avatar URL */
      avatarUrl: string;
      /** @description The conversation ID */
      conversationId: string;
    };
    IgnoredUsersRepDto: {
      results: components["schemas"]["UserForIgnoredConversation"][];
    };
    GetLockInfoFromExtensionRepDto: {
      /** @description The extension configuration. */
      extension: Record<string, never>;
      /** @description The lock */
      lock: components["schemas"]["LockForPublic"];
    };
    TriggerExtensionActionDto: {
      /**
       * @description The action name
       * Refer to the extension documentation to know the available actions
       */
      action: string;
      /** @description The action payload */
      payload: Record<string, never>;
    };
    TemporaryOpeningSetCombinationDto: {
      combinationId: string;
    };
    CommunityEventAction: {
      name: string;
      title: string;
      description: string | null;
      points: number;
      maxPerPeriod?: number;
      group?: string;
    };
    CommunityEventCategory: {
      name: string;
      title: string;
      maxPoints: number | null;
      actions: components["schemas"]["CommunityEventAction"][];
      hidden?: boolean;
    };
    GetPeriodDetailsDto: {
      /** Format: date-time */
      date: string;
    };
    GetPeriodDetailsRepDto: {
      categories: {
        [key: string]: number;
      };
      actions: {
        [key: string]: number;
      };
      /** Format: date-time */
      start: string;
      /** Format: date-time */
      end: string;
    };
    LockExtensionConfigDto: {
      /** @description The extension slug. */
      slug: string;
      /** @description The extension configuration. */
      config: Record<string, never>;
      partnerConfigurationToken?: string;
      /** @enum {string} */
      mode: "cumulative" | "non_cumulative" | "turn" | "unlimited";
      regularity: number;
    };
    CreateLockDto: {
      /** @description Min duration in seconds */
      minDuration: number;
      /** @description Max duration in seconds */
      maxDuration: number;
      /** @description Max limit duration in seconds */
      maxLimitDuration: number | null;
      /** @description True if the user can view the remaining time */
      displayRemainingTime: boolean;
      /** @description True if the lock is limited in duration */
      limitLockTime: boolean;
      /**
       * @description The combination id
       *
       * A combination object can be created by using the combination endpoints.
       */
      combinationId: string;
      extensions: components["schemas"]["LockExtensionConfigDto"][];
      /** @description True if the wearer can offer the lock to a keyholder */
      allowSessionOffer: boolean;
      /**
       * @description Whether the lock is a test lock and counts in the user stats
       * @default false
       */
      isTestLock: boolean;
      /** @description True if the time information should be hidden from the history */
      hideTimeLogs: boolean;
    };
    LockCreatedRepDto: {
      /** @description The created lock id */
      lockId: string;
    };
    EditLockExtensionsDto: {
      extensions: components["schemas"]["LockExtensionConfigDto"][];
    };
    CreateLockFromSharedLockDto: {
      /** @description The shared lock password, if needed */
      password?: string;
      /** @description The combination id */
      combinationId: string;
      /**
       * @description Whether the lock is a test lock and counts in the user stats
       * Only available if the shared lock allows test locks
       * @default false
       */
      isTestLock: boolean;
    };
    ActionType: {
      type: string;
      icon: string | null;
      color: string | null;
      titleTemplate: string | null;
      descriptionTemplate: string | null;
    };
    PunishableActionModel: {
      /** @description The punishable action name */
      name: string;
      /** @description The punishable action label */
      label: string;
      /**
       * @description The text requesting the required number of actions or limited time
       *
       * Example: Number of dice rolls required
       */
      paramsText?: string;
      /**
       * @description The text indicating the punishments
       *
       * Example: Penalty for not rolling the dice in time
       */
      punishmentText?: string;
      /**
       * @description The punishble action type: Recurring or TimeLimit
       * @enum {string}
       */
      type: "recurring" | "time_limit";
      /** @description The action type counted when the Recurring type if selected. Defaults to `"submit"`. */
      actionType?: string;
    };
    PartnerExtensionForDashboard: {
      /** @description The extension slug. It is unique and cannot be modified. */
      slug: string;
      /** @description Available modes */
      availableModes: components["schemas"]["ExtensionModeEnum"][];
      /**
       * @description If true, the locked user will have to wait the specified time
       * before making his first action
       * @default false
       */
      enableStartTimeout: boolean;
      /**
       * @description Default regularity
       * @default 3600
       */
      defaultRegularity: number;
      /**
       * @description True if the extension is enabled
       * @default true
       */
      isEnabled: boolean;
      /**
       * @description True if the extension is only available to Premium users
       * @default false
       */
      isPremium: boolean;
      /**
       * @description True if the extension is a test extension
       * A test extension is only available to the creator
       * @default true
       */
      isTesting: boolean;
      /**
       * @description Whether the extension is created by members of the community
       * @default true
       */
      isDevelopedByCommunity: boolean;
      /**
       * @description True if the extension is counted in the extensions limit
       * @default true
       */
      isCountedInExtensionsLimit: boolean;
      _id: string;
      /** @description The name displayed to end users */
      displayName: string;
      /** @description The extension subtitle */
      subtitle: string;
      /** @description The extension summary */
      summary: string;
      /**
       * @description The FontAwesome icon, without the `fa-` prefix.
       *
       * The icon must be part of the FontAwesome v5 regular icons:
       * https://fontawesome.com/v5/search?o=r&s=regular
       * @enum {string}
       */
      icon?: "abacus" | "acorn" | "ad" | "address-book" | "address-card" | "adjust" | "air-conditioner" | "air-freshener" | "alarm-clock" | "alarm-exclamation" | "alarm-plus" | "alarm-snooze" | "album-collection" | "album" | "alicorn" | "alien-monster" | "alien" | "align-center" | "align-justify" | "align-left" | "align-right" | "align-slash" | "allergies" | "ambulance" | "american-sign-language-interpreting" | "amp-guitar" | "analytics" | "anchor" | "angel" | "angle-double-down" | "angle-double-left" | "angle-double-right" | "angle-double-up" | "angle-down" | "angle-left" | "angle-right" | "angle-up" | "angry" | "ankh" | "apple-alt" | "apple-crate" | "archive" | "archway" | "arrow-alt-circle-down" | "arrow-alt-circle-left" | "arrow-alt-circle-right" | "arrow-alt-circle-up" | "arrow-alt-down" | "arrow-alt-from-bottom" | "arrow-alt-from-left" | "arrow-alt-from-right" | "arrow-alt-from-top" | "arrow-alt-left" | "arrow-alt-right" | "arrow-alt-square-down" | "arrow-alt-square-left" | "arrow-alt-square-right" | "arrow-alt-square-up" | "arrow-alt-to-bottom" | "arrow-alt-to-left" | "arrow-alt-to-right" | "arrow-alt-to-top" | "arrow-alt-up" | "arrow-circle-down" | "arrow-circle-left" | "arrow-circle-right" | "arrow-circle-up" | "arrow-down" | "arrow-from-bottom" | "arrow-from-left" | "arrow-from-right" | "arrow-from-top" | "arrow-left" | "arrow-right" | "arrow-square-down" | "arrow-square-left" | "arrow-square-right" | "arrow-square-up" | "arrow-to-bottom" | "arrow-to-left" | "arrow-to-right" | "arrow-to-top" | "arrow-up" | "arrows-alt-h" | "arrows-alt-v" | "arrows-alt" | "arrows-h" | "arrows-v" | "arrows" | "assistive-listening-systems" | "asterisk" | "at" | "atlas" | "atom-alt" | "atom" | "audio-description" | "award" | "axe-battle" | "axe" | "baby-carriage" | "baby" | "backpack" | "backspace" | "backward" | "bacon" | "bacteria" | "bacterium" | "badge-check" | "badge-dollar" | "badge-percent" | "badge-sheriff" | "badge" | "badger-honey" | "bags-shopping" | "bahai" | "balance-scale-left" | "balance-scale-right" | "balance-scale" | "ball-pile" | "ballot-check" | "ballot" | "ban" | "band-aid" | "banjo" | "barcode-alt" | "barcode-read" | "barcode-scan" | "barcode" | "bars" | "baseball-ball" | "baseball" | "basketball-ball" | "basketball-hoop" | "bat" | "bath" | "battery-bolt" | "battery-empty" | "battery-full" | "battery-half" | "battery-quarter" | "battery-slash" | "battery-three-quarters" | "bed-alt" | "bed-bunk" | "bed-empty" | "bed" | "beer" | "bell-exclamation" | "bell-on" | "bell-plus" | "bell-school-slash" | "bell-school" | "bell-slash" | "bell" | "bells" | "betamax" | "bezier-curve" | "bible" | "bicycle" | "biking-mountain" | "biking" | "binoculars" | "biohazard" | "birthday-cake" | "blanket" | "blender-phone" | "blender" | "blind" | "blinds-open" | "blinds-raised" | "blinds" | "blog" | "bold" | "bolt" | "bomb" | "bone-break" | "bone" | "bong" | "book-alt" | "book-dead" | "book-heart" | "book-medical" | "book-open" | "book-reader" | "book-spells" | "book-user" | "book" | "bookmark" | "books-medical" | "books" | "boombox" | "boot" | "booth-curtain" | "border-all" | "border-bottom" | "border-center-h" | "border-center-v" | "border-inner" | "border-left" | "border-none" | "border-outer" | "border-right" | "border-style-alt" | "border-style" | "border-top" | "bow-arrow" | "bowling-ball" | "bowling-pins" | "box-alt" | "box-ballot" | "box-check" | "box-fragile" | "box-full" | "box-heart" | "box-open" | "box-tissue" | "box-up" | "box-usd" | "box" | "boxes-alt" | "boxes" | "boxing-glove" | "brackets-curly" | "brackets" | "braille" | "brain" | "bread-loaf" | "bread-slice" | "briefcase-medical" | "briefcase" | "bring-forward" | "bring-front" | "broadcast-tower" | "broom" | "browser" | "brush" | "bug" | "building" | "bullhorn" | "bullseye-arrow" | "bullseye-pointer" | "bullseye" | "burger-soda" | "burn" | "burrito" | "bus-alt" | "bus-school" | "bus" | "business-time" | "cabinet-filing" | "cactus" | "calculator-alt" | "calculator" | "calendar-alt" | "calendar-check" | "calendar-day" | "calendar-edit" | "calendar-exclamation" | "calendar-minus" | "calendar-plus" | "calendar-star" | "calendar-times" | "calendar-week" | "calendar" | "camcorder" | "camera-alt" | "camera-home" | "camera-movie" | "camera-polaroid" | "camera-retro" | "camera" | "campfire" | "campground" | "candle-holder" | "candy-cane" | "candy-corn" | "cannabis" | "capsules" | "car-alt" | "car-battery" | "car-building" | "car-bump" | "car-bus" | "car-crash" | "car-garage" | "car-mechanic" | "car-side" | "car-tilt" | "car-wash" | "car" | "caravan-alt" | "caravan" | "caret-circle-down" | "caret-circle-left" | "caret-circle-right" | "caret-circle-up" | "caret-down" | "caret-left" | "caret-right" | "caret-square-down" | "caret-square-left" | "caret-square-right" | "caret-square-up" | "caret-up" | "carrot" | "cars" | "cart-arrow-down" | "cart-plus" | "cash-register" | "cassette-tape" | "cat-space" | "cat" | "cauldron" | "cctv" | "certificate" | "chair-office" | "chair" | "chalkboard-teacher" | "chalkboard" | "charging-station" | "chart-area" | "chart-bar" | "chart-line-down" | "chart-line" | "chart-network" | "chart-pie-alt" | "chart-pie" | "chart-scatter" | "check-circle" | "check-double" | "check-square" | "check" | "cheese-swiss" | "cheese" | "cheeseburger" | "chess-bishop-alt" | "chess-bishop" | "chess-board" | "chess-clock-alt" | "chess-clock" | "chess-king-alt" | "chess-king" | "chess-knight-alt" | "chess-knight" | "chess-pawn-alt" | "chess-pawn" | "chess-queen-alt" | "chess-queen" | "chess-rook-alt" | "chess-rook" | "chess" | "chevron-circle-down" | "chevron-circle-left" | "chevron-circle-right" | "chevron-circle-up" | "chevron-double-down" | "chevron-double-left" | "chevron-double-right" | "chevron-double-up" | "chevron-down" | "chevron-left" | "chevron-right" | "chevron-square-down" | "chevron-square-left" | "chevron-square-right" | "chevron-square-up" | "chevron-up" | "child" | "chimney" | "church" | "circle-notch" | "circle" | "city" | "clarinet" | "claw-marks" | "clinic-medical" | "clipboard-check" | "clipboard-list-check" | "clipboard-list" | "clipboard-prescription" | "clipboard-user" | "clipboard" | "clock" | "clone" | "closed-captioning" | "cloud-download-alt" | "cloud-download" | "cloud-drizzle" | "cloud-hail-mixed" | "cloud-hail" | "cloud-meatball" | "cloud-moon-rain" | "cloud-moon" | "cloud-music" | "cloud-rain" | "cloud-rainbow" | "cloud-showers-heavy" | "cloud-showers" | "cloud-sleet" | "cloud-snow" | "cloud-sun-rain" | "cloud-sun" | "cloud-upload-alt" | "cloud-upload" | "cloud" | "clouds-moon" | "clouds-sun" | "clouds" | "club" | "cocktail" | "code-branch" | "code-commit" | "code-merge" | "code" | "coffee-pot" | "coffee-togo" | "coffee" | "coffin-cross" | "coffin" | "cog" | "cogs" | "coin" | "coins" | "columns" | "comet" | "comment-alt-check" | "comment-alt-dollar" | "comment-alt-dots" | "comment-alt-edit" | "comment-alt-exclamation" | "comment-alt-lines" | "comment-alt-medical" | "comment-alt-minus" | "comment-alt-music" | "comment-alt-plus" | "comment-alt-slash" | "comment-alt-smile" | "comment-alt-times" | "comment-alt" | "comment-check" | "comment-dollar" | "comment-dots" | "comment-edit" | "comment-exclamation" | "comment-lines" | "comment-medical" | "comment-minus" | "comment-music" | "comment-plus" | "comment-slash" | "comment-smile" | "comment-times" | "comment" | "comments-alt-dollar" | "comments-alt" | "comments-dollar" | "comments" | "compact-disc" | "compass-slash" | "compass" | "compress-alt" | "compress-arrows-alt" | "compress-wide" | "compress" | "computer-classic" | "computer-speaker" | "concierge-bell" | "construction" | "container-storage" | "conveyor-belt-alt" | "conveyor-belt" | "cookie-bite" | "cookie" | "copy" | "copyright" | "corn" | "couch" | "cow" | "cowbell-more" | "cowbell" | "credit-card-blank" | "credit-card-front" | "credit-card" | "cricket" | "croissant" | "crop-alt" | "crop" | "cross" | "crosshairs" | "crow" | "crown" | "crutch" | "crutches" | "cube" | "cubes" | "curling" | "cut" | "dagger" | "database" | "deaf" | "debug" | "deer-rudolph" | "deer" | "democrat" | "desktop-alt" | "desktop" | "dewpoint" | "dharmachakra" | "diagnoses" | "diamond" | "dice-d10" | "dice-d12" | "dice-d20" | "dice-d4" | "dice-d6" | "dice-d8" | "dice-five" | "dice-four" | "dice-one" | "dice-six" | "dice-three" | "dice-two" | "dice" | "digging" | "digital-tachograph" | "diploma" | "directions" | "disc-drive" | "disease" | "divide" | "dizzy" | "dna" | "do-not-enter" | "dog-leashed" | "dog" | "dollar-sign" | "dolly-empty" | "dolly-flatbed-alt" | "dolly-flatbed-empty" | "dolly-flatbed" | "dolly" | "donate" | "door-closed" | "door-open" | "dot-circle" | "dove" | "download" | "drafting-compass" | "dragon" | "draw-circle" | "draw-polygon" | "draw-square" | "dreidel" | "drone-alt" | "drone" | "drum-steelpan" | "drum" | "drumstick-bite" | "drumstick" | "dryer-alt" | "dryer" | "duck" | "dumbbell" | "dumpster-fire" | "dumpster" | "dungeon" | "ear-muffs" | "ear" | "eclipse-alt" | "eclipse" | "edit" | "egg-fried" | "egg" | "eject" | "elephant" | "ellipsis-h-alt" | "ellipsis-h" | "ellipsis-v-alt" | "ellipsis-v" | "empty-set" | "engine-warning" | "envelope-open-dollar" | "envelope-open-text" | "envelope-open" | "envelope-square" | "envelope" | "equals" | "eraser" | "ethernet" | "euro-sign" | "exchange-alt" | "exchange" | "exclamation-circle" | "exclamation-square" | "exclamation-triangle" | "exclamation" | "expand-alt" | "expand-arrows-alt" | "expand-arrows" | "expand-wide" | "expand" | "external-link-alt" | "external-link-square-alt" | "external-link-square" | "external-link" | "eye-dropper" | "eye-evil" | "eye-slash" | "eye" | "fan-table" | "fan" | "farm" | "fast-backward" | "fast-forward" | "faucet-drip" | "faucet" | "fax" | "feather-alt" | "feather" | "female" | "field-hockey" | "fighter-jet" | "file-alt" | "file-archive" | "file-audio" | "file-certificate" | "file-chart-line" | "file-chart-pie" | "file-check" | "file-code" | "file-contract" | "file-csv" | "file-download" | "file-edit" | "file-excel" | "file-exclamation" | "file-export" | "file-image" | "file-import" | "file-invoice-dollar" | "file-invoice" | "file-medical-alt" | "file-medical" | "file-minus" | "file-music" | "file-pdf" | "file-plus" | "file-powerpoint" | "file-prescription" | "file-search" | "file-signature" | "file-spreadsheet" | "file-times" | "file-upload" | "file-user" | "file-video" | "file-word" | "file" | "files-medical" | "fill-drip" | "fill" | "film-alt" | "film-canister" | "film" | "filter" | "fingerprint" | "fire-alt" | "fire-extinguisher" | "fire-smoke" | "fire" | "fireplace" | "first-aid" | "fish-cooked" | "fish" | "fist-raised" | "flag-alt" | "flag-checkered" | "flag-usa" | "flag" | "flame" | "flashlight" | "flask-poison" | "flask-potion" | "flask" | "flower-daffodil" | "flower-tulip" | "flower" | "flushed" | "flute" | "flux-capacitor" | "fog" | "folder-download" | "folder-minus" | "folder-open" | "folder-plus" | "folder-times" | "folder-tree" | "folder-upload" | "folder" | "folders" | "font-awesome-logo-full" | "font-case" | "font" | "football-ball" | "football-helmet" | "forklift" | "forward" | "fragile" | "french-fries" | "frog" | "frosty-head" | "frown-open" | "frown" | "function" | "funnel-dollar" | "futbol" | "galaxy" | "game-board-alt" | "game-board" | "game-console-handheld" | "gamepad-alt" | "gamepad" | "garage-car" | "garage-open" | "garage" | "gas-pump-slash" | "gas-pump" | "gavel" | "gem" | "genderless" | "ghost" | "gift-card" | "gift" | "gifts" | "gingerbread-man" | "glass-champagne" | "glass-cheers" | "glass-citrus" | "glass-martini-alt" | "glass-martini" | "glass-whiskey-rocks" | "glass-whiskey" | "glass" | "glasses-alt" | "glasses" | "globe-africa" | "globe-americas" | "globe-asia" | "globe-europe" | "globe-snow" | "globe-stand" | "globe" | "golf-ball" | "golf-club" | "gopuram" | "graduation-cap" | "gramophone" | "greater-than-equal" | "greater-than" | "grimace" | "grin-alt" | "grin-beam-sweat" | "grin-beam" | "grin-hearts" | "grin-squint-tears" | "grin-squint" | "grin-stars" | "grin-tears" | "grin-tongue-squint" | "grin-tongue-wink" | "grin-tongue" | "grin-wink" | "grin" | "grip-horizontal" | "grip-lines-vertical" | "grip-lines" | "grip-vertical" | "guitar-electric" | "guitar" | "guitars" | "h-square" | "h1" | "h2" | "h3" | "h4" | "hamburger" | "hammer-war" | "hammer" | "hamsa" | "hand-heart" | "hand-holding-box" | "hand-holding-heart" | "hand-holding-magic" | "hand-holding-medical" | "hand-holding-seedling" | "hand-holding-usd" | "hand-holding-water" | "hand-holding" | "hand-lizard" | "hand-middle-finger" | "hand-paper" | "hand-peace" | "hand-point-down" | "hand-point-left" | "hand-point-right" | "hand-point-up" | "hand-pointer" | "hand-receiving" | "hand-rock" | "hand-scissors" | "hand-sparkles" | "hand-spock" | "hands-heart" | "hands-helping" | "hands-usd" | "hands-wash" | "hands" | "handshake-alt-slash" | "handshake-alt" | "handshake-slash" | "handshake" | "hanukiah" | "hard-hat" | "hashtag" | "hat-chef" | "hat-cowboy-side" | "hat-cowboy" | "hat-santa" | "hat-winter" | "hat-witch" | "hat-wizard" | "hdd" | "head-side-brain" | "head-side-cough-slash" | "head-side-cough" | "head-side-headphones" | "head-side-mask" | "head-side-medical" | "head-side-virus" | "head-side" | "head-vr" | "heading" | "headphones-alt" | "headphones" | "headset" | "heart-broken" | "heart-circle" | "heart-rate" | "heart-square" | "heart" | "heartbeat" | "heat" | "helicopter" | "helmet-battle" | "hexagon" | "highlighter" | "hiking" | "hippo" | "history" | "hockey-mask" | "hockey-puck" | "hockey-sticks" | "holly-berry" | "home-alt" | "home-heart" | "home-lg-alt" | "home-lg" | "home" | "hood-cloak" | "horizontal-rule" | "horse-head" | "horse-saddle" | "horse" | "hospital-alt" | "hospital-symbol" | "hospital-user" | "hospital" | "hospitals" | "hot-tub" | "hotdog" | "hotel" | "hourglass-end" | "hourglass-half" | "hourglass-start" | "hourglass" | "house-damage" | "house-day" | "house-flood" | "house-leave" | "house-night" | "house-return" | "house-signal" | "house-user" | "house" | "hryvnia" | "humidity" | "hurricane" | "i-cursor" | "ice-cream" | "ice-skate" | "icicles" | "icons-alt" | "icons" | "id-badge" | "id-card-alt" | "id-card" | "igloo" | "image-polaroid" | "image" | "images" | "inbox-in" | "inbox-out" | "inbox" | "indent" | "industry-alt" | "industry" | "infinity" | "info-circle" | "info-square" | "info" | "inhaler" | "integral" | "intersection" | "inventory" | "island-tropical" | "italic" | "jack-o-lantern" | "jedi" | "joint" | "journal-whills" | "joystick" | "jug" | "kaaba" | "kazoo" | "kerning" | "key-skeleton" | "key" | "keyboard" | "keynote" | "khanda" | "kidneys" | "kiss-beam" | "kiss-wink-heart" | "kiss" | "kite" | "kiwi-bird" | "knife-kitchen" | "lambda" | "lamp-desk" | "lamp-floor" | "lamp" | "landmark-alt" | "landmark" | "language" | "laptop-code" | "laptop-house" | "laptop-medical" | "laptop" | "lasso" | "laugh-beam" | "laugh-squint" | "laugh-wink" | "laugh" | "layer-group" | "layer-minus" | "layer-plus" | "leaf-heart" | "leaf-maple" | "leaf-oak" | "leaf" | "lemon" | "less-than-equal" | "less-than" | "level-down-alt" | "level-down" | "level-up-alt" | "level-up" | "life-ring" | "light-ceiling" | "light-switch-off" | "light-switch-on" | "light-switch" | "lightbulb-dollar" | "lightbulb-exclamation" | "lightbulb-on" | "lightbulb-slash" | "lightbulb" | "lights-holiday" | "line-columns" | "line-height" | "link" | "lips" | "lira-sign" | "list-alt" | "list-music" | "list-ol" | "list-ul" | "list" | "location-arrow" | "location-circle" | "location-slash" | "location" | "lock-alt" | "lock-open-alt" | "lock-open" | "lock" | "long-arrow-alt-down" | "long-arrow-alt-left" | "long-arrow-alt-right" | "long-arrow-alt-up" | "long-arrow-down" | "long-arrow-left" | "long-arrow-right" | "long-arrow-up" | "loveseat" | "low-vision" | "luchador" | "luggage-cart" | "lungs-virus" | "lungs" | "mace" | "magic" | "magnet" | "mail-bulk" | "mailbox" | "male" | "mandolin" | "map-marked-alt" | "map-marked" | "map-marker-alt-slash" | "map-marker-alt" | "map-marker-check" | "map-marker-edit" | "map-marker-exclamation" | "map-marker-minus" | "map-marker-plus" | "map-marker-question" | "map-marker-slash" | "map-marker-smile" | "map-marker-times" | "map-marker" | "map-pin" | "map-signs" | "map" | "marker" | "mars-double" | "mars-stroke-h" | "mars-stroke-v" | "mars-stroke" | "mars" | "mask" | "meat" | "medal" | "medkit" | "megaphone" | "meh-blank" | "meh-rolling-eyes" | "meh" | "memory" | "menorah" | "mercury" | "meteor" | "microchip" | "microphone-alt-slash" | "microphone-alt" | "microphone-slash" | "microphone-stand" | "microphone" | "microscope" | "microwave" | "mind-share" | "minus-circle" | "minus-hexagon" | "minus-octagon" | "minus-square" | "minus" | "mistletoe" | "mitten" | "mobile-alt" | "mobile-android-alt" | "mobile-android" | "mobile" | "money-bill-alt" | "money-bill-wave-alt" | "money-bill-wave" | "money-bill" | "money-check-alt" | "money-check-edit-alt" | "money-check-edit" | "money-check" | "monitor-heart-rate" | "monkey" | "monument" | "moon-cloud" | "moon-stars" | "moon" | "mortar-pestle" | "mosque" | "motorcycle" | "mountain" | "mountains" | "mouse-alt" | "mouse-pointer" | "mouse" | "mp3-player" | "mug-hot" | "mug-marshmallows" | "mug-tea" | "mug" | "music-alt-slash" | "music-alt" | "music-slash" | "music" | "narwhal" | "network-wired" | "neuter" | "newspaper" | "not-equal" | "notes-medical" | "object-group" | "object-ungroup" | "octagon" | "oil-can" | "oil-temp" | "om" | "omega" | "ornament" | "otter" | "outdent" | "outlet" | "oven" | "overline" | "page-break" | "pager" | "paint-brush-alt" | "paint-brush" | "paint-roller" | "palette" | "pallet-alt" | "pallet" | "paper-plane" | "paperclip" | "parachute-box" | "paragraph-rtl" | "paragraph" | "parking-circle-slash" | "parking-circle" | "parking-slash" | "parking" | "passport" | "pastafarianism" | "paste" | "pause-circle" | "pause" | "paw-alt" | "paw-claws" | "paw" | "peace" | "pegasus" | "pen-alt" | "pen-fancy" | "pen-nib" | "pen-square" | "pen" | "pencil-alt" | "pencil-paintbrush" | "pencil-ruler" | "pencil" | "pennant" | "people-arrows" | "people-carry" | "pepper-hot" | "percent" | "percentage" | "person-booth" | "person-carry" | "person-dolly-empty" | "person-dolly" | "person-sign" | "phone-alt" | "phone-laptop" | "phone-office" | "phone-plus" | "phone-rotary" | "phone-slash" | "phone-square-alt" | "phone-square" | "phone-volume" | "phone" | "photo-video" | "pi" | "piano-keyboard" | "piano" | "pie" | "pig" | "piggy-bank" | "pills" | "pizza-slice" | "pizza" | "place-of-worship" | "plane-alt" | "plane-arrival" | "plane-departure" | "plane-slash" | "plane" | "planet-moon" | "planet-ringed" | "play-circle" | "play" | "plug" | "plus-circle" | "plus-hexagon" | "plus-octagon" | "plus-square" | "plus" | "podcast" | "podium-star" | "podium" | "police-box" | "poll-h" | "poll-people" | "poll" | "poo-storm" | "poo" | "poop" | "popcorn" | "portal-enter" | "portal-exit" | "portrait" | "pound-sign" | "power-off" | "pray" | "praying-hands" | "prescription-bottle-alt" | "prescription-bottle" | "prescription" | "presentation" | "print-search" | "print-slash" | "print" | "procedures" | "project-diagram" | "projector" | "pump-medical" | "pump-soap" | "pumpkin" | "puzzle-piece" | "qrcode" | "question-circle" | "question-square" | "question" | "quidditch" | "quote-left" | "quote-right" | "quran" | "rabbit-fast" | "rabbit" | "racquet" | "radar" | "radiation-alt" | "radiation" | "radio-alt" | "radio" | "rainbow" | "raindrops" | "ram" | "ramp-loading" | "random" | "raygun" | "receipt" | "record-vinyl" | "rectangle-landscape" | "rectangle-portrait" | "rectangle-wide" | "recycle" | "redo-alt" | "redo" | "refrigerator" | "registered" | "remove-format" | "repeat-1-alt" | "repeat-1" | "repeat-alt" | "repeat" | "reply-all" | "reply" | "republican" | "restroom" | "retweet-alt" | "retweet" | "ribbon" | "ring" | "rings-wedding" | "road" | "robot" | "rocket-launch" | "rocket" | "route-highway" | "route-interstate" | "route" | "router" | "rss-square" | "rss" | "ruble-sign" | "ruler-combined" | "ruler-horizontal" | "ruler-triangle" | "ruler-vertical" | "ruler" | "running" | "rupee-sign" | "rv" | "sack-dollar" | "sack" | "sad-cry" | "sad-tear" | "salad" | "sandwich" | "satellite-dish" | "satellite" | "sausage" | "save" | "sax-hot" | "saxophone" | "scalpel-path" | "scalpel" | "scanner-image" | "scanner-keyboard" | "scanner-touchscreen" | "scanner" | "scarecrow" | "scarf" | "school" | "screwdriver" | "scroll-old" | "scroll" | "scrubber" | "scythe" | "sd-card" | "search-dollar" | "search-location" | "search-minus" | "search-plus" | "search" | "seedling" | "send-back" | "send-backward" | "sensor-alert" | "sensor-fire" | "sensor-on" | "sensor-smoke" | "sensor" | "server" | "shapes" | "share-all" | "share-alt-square" | "share-alt" | "share-square" | "share" | "sheep" | "shekel-sign" | "shield-alt" | "shield-check" | "shield-cross" | "shield-virus" | "shield" | "ship" | "shipping-fast" | "shipping-timed" | "shish-kebab" | "shoe-prints" | "shopping-bag" | "shopping-basket" | "shopping-cart" | "shovel-snow" | "shovel" | "shower" | "shredder" | "shuttle-van" | "shuttlecock" | "sickle" | "sigma" | "sign-in-alt" | "sign-in" | "sign-language" | "sign-out-alt" | "sign-out" | "sign" | "signal-1" | "signal-2" | "signal-3" | "signal-4" | "signal-alt-1" | "signal-alt-2" | "signal-alt-3" | "signal-alt-slash" | "signal-alt" | "signal-slash" | "signal-stream" | "signal" | "signature" | "sim-card" | "sink" | "siren-on" | "siren" | "sitemap" | "skating" | "skeleton" | "ski-jump" | "ski-lift" | "skiing-nordic" | "skiing" | "skull-cow" | "skull-crossbones" | "skull" | "slash" | "sledding" | "sleigh" | "sliders-h-square" | "sliders-h" | "sliders-v-square" | "sliders-v" | "smile-beam" | "smile-plus" | "smile-wink" | "smile" | "smog" | "smoke" | "smoking-ban" | "smoking" | "sms" | "snake" | "snooze" | "snow-blowing" | "snowboarding" | "snowflake" | "snowflakes" | "snowman" | "snowmobile" | "snowplow" | "soap" | "socks" | "solar-panel" | "solar-system" | "sort-alpha-down-alt" | "sort-alpha-down" | "sort-alpha-up-alt" | "sort-alpha-up" | "sort-alt" | "sort-amount-down-alt" | "sort-amount-down" | "sort-amount-up-alt" | "sort-amount-up" | "sort-circle-down" | "sort-circle-up" | "sort-circle" | "sort-down" | "sort-numeric-down-alt" | "sort-numeric-down" | "sort-numeric-up-alt" | "sort-numeric-up" | "sort-shapes-down-alt" | "sort-shapes-down" | "sort-shapes-up-alt" | "sort-shapes-up" | "sort-size-down-alt" | "sort-size-down" | "sort-size-up-alt" | "sort-size-up" | "sort-up" | "sort" | "soup" | "spa" | "space-shuttle" | "space-station-moon-alt" | "space-station-moon" | "spade" | "sparkles" | "speaker" | "speakers" | "spell-check" | "spider-black-widow" | "spider-web" | "spider" | "spinner-third" | "spinner" | "splotch" | "spray-can" | "sprinkler" | "square-full" | "square-root-alt" | "square-root" | "square" | "squirrel" | "staff" | "stamp" | "star-and-crescent" | "star-christmas" | "star-exclamation" | "star-half-alt" | "star-half" | "star-of-david" | "star-of-life" | "star-shooting" | "star" | "starfighter-alt" | "starfighter" | "stars" | "starship-freighter" | "starship" | "steak" | "steering-wheel" | "step-backward" | "step-forward" | "stethoscope" | "sticky-note" | "stocking" | "stomach" | "stop-circle" | "stop" | "stopwatch-20" | "stopwatch" | "store-alt-slash" | "store-alt" | "store-slash" | "store" | "stream" | "street-view" | "stretcher" | "strikethrough" | "stroopwafel" | "subscript" | "subway" | "suitcase-rolling" | "suitcase" | "sun-cloud" | "sun-dust" | "sun-haze" | "sun" | "sunglasses" | "sunrise" | "sunset" | "superscript" | "surprise" | "swatchbook" | "swimmer" | "swimming-pool" | "sword-laser-alt" | "sword-laser" | "sword" | "swords-laser" | "swords" | "synagogue" | "sync-alt" | "sync" | "syringe" | "t" | "table-tennis" | "table" | "tablet-alt" | "tablet-android-alt" | "tablet-android" | "tablet-rugged" | "tablet" | "tablets" | "tachometer-alt-average" | "tachometer-alt-fast" | "tachometer-alt-fastest" | "tachometer-alt-slow" | "tachometer-alt-slowest" | "tachometer-alt" | "tachometer-average" | "tachometer-fast" | "tachometer-fastest" | "tachometer-slow" | "tachometer-slowest" | "tachometer" | "taco" | "tag" | "tags" | "tally" | "tanakh" | "tape" | "tasks-alt" | "tasks" | "taxi" | "teeth-open" | "teeth" | "telescope" | "temperature-down" | "temperature-frigid" | "temperature-high" | "temperature-hot" | "temperature-low" | "temperature-up" | "tenge" | "tennis-ball" | "terminal" | "text-height" | "text-size" | "text-width" | "text" | "th-large" | "th-list" | "th" | "theater-masks" | "thermometer-empty" | "thermometer-full" | "thermometer-half" | "thermometer-quarter" | "thermometer-three-quarters" | "thermometer" | "theta" | "thumbs-down" | "thumbs-up" | "thumbtack" | "thunderstorm-moon" | "thunderstorm-sun" | "thunderstorm" | "ticket-alt" | "ticket" | "tilde" | "times-circle" | "times-hexagon" | "times-octagon" | "times-square" | "times" | "tint-slash" | "tint" | "tire-flat" | "tire-pressure-warning" | "tire-rugged" | "tire" | "tired" | "toggle-off" | "toggle-on" | "toilet-paper-alt" | "toilet-paper-slash" | "toilet-paper" | "toilet" | "tombstone-alt" | "tombstone" | "toolbox" | "tools" | "tooth" | "toothbrush" | "torah" | "torii-gate" | "tornado" | "tractor" | "trademark" | "traffic-cone" | "traffic-light-go" | "traffic-light-slow" | "traffic-light-stop" | "traffic-light" | "trailer" | "train" | "tram" | "transgender-alt" | "transgender" | "transporter-1" | "transporter-2" | "transporter-3" | "transporter-empty" | "transporter" | "trash-alt" | "trash-restore-alt" | "trash-restore" | "trash-undo-alt" | "trash-undo" | "trash" | "treasure-chest" | "tree-alt" | "tree-christmas" | "tree-decorated" | "tree-large" | "tree-palm" | "tree" | "trees" | "triangle-music" | "triangle" | "trophy-alt" | "trophy" | "truck-container" | "truck-couch" | "truck-loading" | "truck-monster" | "truck-moving" | "truck-pickup" | "truck-plow" | "truck-ramp" | "truck" | "trumpet" | "tshirt" | "tty" | "turkey" | "turntable" | "turtle" | "tv-alt" | "tv-music" | "tv-retro" | "tv" | "typewriter" | "ufo-beam" | "ufo" | "umbrella-beach" | "umbrella" | "underline" | "undo-alt" | "undo" | "unicorn" | "union" | "universal-access" | "university" | "unlink" | "unlock-alt" | "unlock" | "upload" | "usb-drive" | "usd-circle" | "usd-square" | "user-alien" | "user-alt-slash" | "user-alt" | "user-astronaut" | "user-chart" | "user-check" | "user-circle" | "user-clock" | "user-cog" | "user-cowboy" | "user-crown" | "user-edit" | "user-friends" | "user-graduate" | "user-hard-hat" | "user-headset" | "user-injured" | "user-lock" | "user-md-chat" | "user-md" | "user-minus" | "user-music" | "user-ninja" | "user-nurse" | "user-plus" | "user-robot" | "user-secret" | "user-shield" | "user-slash" | "user-tag" | "user-tie" | "user-times" | "user-unlock" | "user-visor" | "user" | "users-class" | "users-cog" | "users-crown" | "users-medical" | "users-slash" | "users" | "utensil-fork" | "utensil-knife" | "utensil-spoon" | "utensils-alt" | "utensils" | "vacuum-robot" | "vacuum" | "value-absolute" | "vector-square" | "venus-double" | "venus-mars" | "venus" | "vest-patches" | "vest" | "vhs" | "vial" | "vials" | "video-plus" | "video-slash" | "video" | "vihara" | "violin" | "virus-slash" | "virus" | "viruses" | "voicemail" | "volcano" | "volleyball-ball" | "volume-down" | "volume-mute" | "volume-off" | "volume-slash" | "volume-up" | "volume" | "vote-nay" | "vote-yea" | "vr-cardboard" | "wagon-covered" | "walker" | "walkie-talkie" | "walking" | "wallet" | "wand-magic" | "wand" | "warehouse-alt" | "warehouse" | "washer" | "watch-calculator" | "watch-fitness" | "watch" | "water-lower" | "water-rise" | "water" | "wave-sine" | "wave-square" | "wave-triangle" | "waveform-path" | "waveform" | "webcam-slash" | "webcam" | "weight-hanging" | "weight" | "whale" | "wheat" | "wheelchair" | "whistle" | "wifi-1" | "wifi-2" | "wifi-slash" | "wifi" | "wind-turbine" | "wind-warning" | "wind" | "window-alt" | "window-close" | "window-frame-open" | "window-frame" | "window-maximize" | "window-minimize" | "window-restore" | "window" | "windsock" | "wine-bottle" | "wine-glass-alt" | "wine-glass" | "won-sign" | "wreath" | "wrench" | "x-ray" | "yen-sign" | "yin-yang";
      /** @description The application Keycloak id */
      applicationId: string;
      /**
       * @description Default configuration
       * This can be an object of any form, and will be returned to you in the queries.
       */
      defaultConfig: Record<string, never>;
      /**
       * @description Default data
       * This can be an object of any form, and will be returned to you in the queries.
       */
      defaultData: Record<string, never>;
      /**
       * @description List of extension log actions
       *
       * This list of actions will be loaded at startup and can be used by all extensions.
       * @default []
       */
      actions: components["schemas"]["ActionType"][];
      /**
       * @description Returns an extension configuration description.
       * This string is a Handlebars template with the config in parameters.
       * This text can be displayed to the user.
       */
      configDescription: string | null;
      /**
       * @description List of punishable actions
       * @default []
       */
      punishableActions: components["schemas"]["PunishableActionModel"][];
      /** @description The iframe extension url */
      mainIframeUrl: string;
      /** @description The iframe configuration url */
      configIframeUrl: string;
      /** @description The webhook url */
      webhookUrl: string;
      /** @description The webhook username */
      webhookUsername: string;
      /** @description The webhook username */
      webhookPassword: string;
      /**
       * Format: date-time
       * @description Deleted at
       */
      deletedAt: string | null;
    };
    CreatePartnerExtensionDto: {
      /** @description The name displayed to end users */
      displayName: string;
    };
    UpdatePartnerExtensionDto: {
      /** @description Available modes */
      availableModes?: components["schemas"]["ExtensionModeEnum"][];
      /**
       * @description If true, the locked user will have to wait the specified time
       * before making his first action
       * @default false
       */
      enableStartTimeout?: boolean;
      /**
       * @description Default regularity
       * @default 3600
       */
      defaultRegularity?: number;
      /**
       * @description True if the extension is enabled
       * @default true
       */
      isEnabled?: boolean;
      /**
       * @description True if the extension is a test extension
       * A test extension is only available to the creator
       * @default true
       */
      isTesting?: boolean;
      /** @description The name displayed to end users */
      displayName?: string;
      /** @description The extension subtitle */
      subtitle?: string;
      /** @description The extension summary */
      summary?: string;
      /** @description The iframe extension url */
      mainIframeUrl?: string;
      /** @description The iframe configuration url */
      configIframeUrl?: string;
      /** @description The webhook url */
      webhookUrl?: string;
      /**
       * @description Default configuration
       * This can be an object of any form, and will be returned to you in the queries.
       */
      defaultConfig?: Record<string, never>;
      /**
       * @description Default data
       * This can be an object of any form, and will be returned to you in the queries.
       */
      defaultData?: Record<string, never>;
      /**
       * @description Returns an extension configuration description.
       * This string is a Handlebars template with the config in parameters.
       * This text can be displayed to the user.
       */
      configDescription?: string | null;
      /** @description The webhook username */
      webhookUsername?: string;
      /** @description The webhook username */
      webhookPassword?: string;
    };
    ExtensionHomeAction: {
      /** @description An identifier that is returned to the extension when the user navigates to the extension page. */
      slug: string;
      /** @description The title displayed on the list item for the action. */
      title: string;
      /** @description The description displayed on the list item for the action. */
      description: string;
      /** @description The icon associated with the action, which must be one of the valid FontAwesome 5 icons. */
      icon: string;
      /** @description Displays a small badge on the list item, useful for indicating notifications or counts associated with the action (e.g., the number of tasks to do or remaining actions in the extension). */
      badge?: string;
    };
    PartnerMetadata: {
      /**
       * @description List of reasons blocking the unlocking of the lock.
       * In order for the lock to be unlocked (except when the time limit is exceeded),
       * all extensions must return an empty list.
       */
      reasonsPreventingUnlocking: string[];
      /**
       * @description A list of actions that will be displayed on the user lock page.
       * When the user clicks on the action, they will be redirected to the
       * extension page, with a parameter corresponding to the slug of the action.
       */
      homeActions: components["schemas"]["ExtensionHomeAction"][];
    };
    ExtensionSessionForPartner: {
      /** @description The extension slug. */
      slug: string;
      /** @description The extension configuration. */
      config: Record<string, never>;
      _id: string;
      /** @description This is the name of the extension, which will be displayed to other users in the list of extensions, and in the description of locks. */
      displayName: string;
      /** @description This is the description of your extension, it is a paragraph explaining how your extension works, and what its purpose is. */
      summary: string;
      /** @description This is the subtitle of the extension, it is a short sentence explaining the concept of your extension, and will be displayed in the list of extensions. */
      subtitle: string;
      /**
       * @description The icon you choose must be one of the regular icons available on FontAwesome 5, which you can find list here. The icon will be displayed in the list of extensions.
       *
       * Contact us if you want to change the icon of your extension.
       */
      icon: string;
      /**
       * @description An extension can offer different modes, depending on the way it works and the actions to be performed. An action is a user interaction, for example in Chaster extensions, spinning the wheel of fortune, assigning a task, or checking in. The frequency of the actions can be defined and limited according to the mode chosen by the user among the modes offered by the extension.
       *
       * More information: https://docs.chaster.app/api/extensions-api/configuration#available-modes
       * @enum {string}
       */
      mode: "cumulative" | "non_cumulative" | "turn" | "unlimited";
      userData: Record<string, never>;
      /** @description The regularity displayed in the configuration, if the user chooses the cumulative or non-cumulative mode. If you enable only Unlimited mode, you don't need to fill this parameter. */
      regularity: number;
      /**
       * @description The number of regular actions remaining. If the mode is Unlimited, it returns -1.
       *
       * Use it to display the number of actions remaining to the user, and know when the user can perform a regular action.
       * If the value is 0, the user cannot perform a regular action.
       */
      nbActionsRemaining: number;
      /**
       * @description The date when the next regular action can be performed.
       *
       * Use it to compare the current date with the next action date to know when the user can perform a regular action.
       * If the value is null, the user can perform a regular action.
       * If the mode is Unlimited, it always returns null.
       */
      nextActionDate?: string;
      isPartner: boolean;
      textConfig: string;
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string;
      sessionId: string;
      /** @description Data stored for this session, in a key-value format. */
      data: Record<string, never>;
      metadata: components["schemas"]["PartnerMetadata"];
      lock: components["schemas"]["LockForPublic"];
    };
    GetPartnerSessionRepDto: {
      session: components["schemas"]["ExtensionSessionForPartner"];
    };
    PatchExtensionSessionDto: {
      /** @description The extension configuration. */
      config?: Record<string, never>;
      metadata?: components["schemas"]["PartnerMetadata"];
      /** @description Data stored for this session, in a key-value format. */
      data?: Record<string, never>;
    };
    AddTimeLockActionModel: {
      /**
       * @description Add time to a lock
       * @enum {string}
       */
      name: "add_time";
      /** @description The amount of time to add, in seconds */
      params: number;
    };
    RemoveTimeLockActionModel: {
      /**
       * @description Remove time to a lock
       * @enum {string}
       */
      name: "remove_time";
      /** @description The amount of time to remove, in seconds */
      params: number;
    };
    FreezeLockActionModel: {
      /**
       * @description Freeze a lock
       * @enum {string}
       */
      name: "freeze";
    };
    UnfreezeLockActionModel: {
      /**
       * @description Unfreeze a lock
       * @enum {string}
       */
      name: "unfreeze";
    };
    ToggleFreezeLockActionModel: {
      /**
       * @description Toggle the freeze status of a lock
       * @enum {string}
       */
      name: "toggle_freeze";
    };
    PilloryLockActionParamsModel: {
      /** @description The pillory duration, in seconds */
      duration: number;
      /** @description The text that will be displayed on the pillory */
      reason?: string;
    };
    PilloryLockActionModel: {
      /**
       * @description Put a user in pillory for the given duration.
       * Note: this only works if the user has enabled the pillory extension.
       * @enum {string}
       */
      name: "pillory";
      params: components["schemas"]["PilloryLockActionParamsModel"];
    };
    PartnerDoActionDto: {
      action: components["schemas"]["AddTimeLockActionModel"] | components["schemas"]["RemoveTimeLockActionModel"] | components["schemas"]["FreezeLockActionModel"] | components["schemas"]["UnfreezeLockActionModel"] | components["schemas"]["ToggleFreezeLockActionModel"] | components["schemas"]["PilloryLockActionModel"];
    };
    /** @enum {string} */
    LockRoleEnum: "keyholder" | "wearer" | "visitor";
    GetPartnerLogsDto: {
      /**
       * @description The user type who is requesting the action logs. By default, it is a visitor.
       *
       * It can be either the wearer or the keyholder, or a visitor without any rights. This is used to display the correct information to the user. For example, if the wearer is requesting logs but the current session timer is hidden, the logs will be displayed with the timer hidden.
       * @default visitor
       */
      role: components["schemas"]["LockRoleEnum"];
      /**
       * @description Limit of action logs to return. Default is 15.
       * @default 15
       */
      limit?: number;
      /** @description Offset lastId, used for pagination. If provided, all logs after this id will be returned. */
      lastId?: string;
      /**
       * @description If true, only action logs from your extension will be returned.
       * @default false
       */
      showOnlyExtensionActions?: boolean;
    };
    PartnerSetMetadataDto: {
      metadata: components["schemas"]["PartnerMetadata"];
    };
    /** @enum {string} */
    GetSessionsDtoStatus: "locked" | "unlocked" | "deserted" | "all";
    GetSessionsDto: {
      /**
       * @description The status of the locks to return. The default value returns ongoing sessions (status Locked).
       * @default locked
       */
      status: components["schemas"]["GetSessionsDtoStatus"];
      /** @description The extension slug. This field is required. */
      extensionSlug: string;
      /**
       * @description Limit of extension sessions to return. Default is 15.
       * @default 15
       */
      limit: number;
      /** @description Offset lastId, used for pagination. If provided, all extension sessions after this id will be returned. */
      paginationLastId?: string;
    };
    ExtensionSessionForSearch: {
      /** @description The extension slug. */
      slug: string;
      /** @description The extension configuration. */
      config: Record<string, never>;
      _id: string;
      /** @description This is the name of the extension, which will be displayed to other users in the list of extensions, and in the description of locks. */
      displayName: string;
      /** @description This is the description of your extension, it is a paragraph explaining how your extension works, and what its purpose is. */
      summary: string;
      /** @description This is the subtitle of the extension, it is a short sentence explaining the concept of your extension, and will be displayed in the list of extensions. */
      subtitle: string;
      /**
       * @description The icon you choose must be one of the regular icons available on FontAwesome 5, which you can find list here. The icon will be displayed in the list of extensions.
       *
       * Contact us if you want to change the icon of your extension.
       */
      icon: string;
      /**
       * @description An extension can offer different modes, depending on the way it works and the actions to be performed. An action is a user interaction, for example in Chaster extensions, spinning the wheel of fortune, assigning a task, or checking in. The frequency of the actions can be defined and limited according to the mode chosen by the user among the modes offered by the extension.
       *
       * More information: https://docs.chaster.app/api/extensions-api/configuration#available-modes
       * @enum {string}
       */
      mode: "cumulative" | "non_cumulative" | "turn" | "unlimited";
      userData: Record<string, never>;
      /** @description The regularity displayed in the configuration, if the user chooses the cumulative or non-cumulative mode. If you enable only Unlimited mode, you don't need to fill this parameter. */
      regularity: number;
      /**
       * @description The number of regular actions remaining. If the mode is Unlimited, it returns -1.
       *
       * Use it to display the number of actions remaining to the user, and know when the user can perform a regular action.
       * If the value is 0, the user cannot perform a regular action.
       */
      nbActionsRemaining: number;
      /**
       * @description The date when the next regular action can be performed.
       *
       * Use it to compare the current date with the next action date to know when the user can perform a regular action.
       * If the value is null, the user can perform a regular action.
       * If the mode is Unlimited, it always returns null.
       */
      nextActionDate?: string;
      isPartner: boolean;
      textConfig: string;
      /** @description Created at */
      createdAt: string;
      /** @description Updated at */
      updatedAt: string;
      sessionId: string;
      /** @description Data stored for this session, in a key-value format. */
      data: Record<string, never>;
      metadata: components["schemas"]["PartnerMetadata"];
      lock: components["schemas"]["LockForPublic"];
      paginationId: string;
    };
    GetSessionsRepDto: {
      count: number;
      hasMore: boolean;
      results: components["schemas"]["ExtensionSessionForSearch"][];
    };
    RegularActionForPartner: {
      /** @description Date when the regular action was submitted */
      date: string;
      /**
       * @description The payload of the regular action, if provided when the regular action was
       * submitted
       */
      payload: Record<string, unknown> | null;
    };
    GetRegularActionsRepDto: {
      /** @description The list of previous submitted regular actions. */
      actions: components["schemas"]["RegularActionForPartner"][];
      /**
       * @description The number of regular actions remaining. If the mode is Unlimited, it returns -1.
       *
       * Use it to display the number of actions remaining to the user, and know when the user can perform a regular action.
       * If the value is 0, the user cannot perform a regular action.
       */
      nbActionsRemaining: number;
      /**
       * @description The date when the next regular action can be performed.
       *
       * Use it to compare the current date with the next action date to know when the user can perform a regular action.
       * If the value is null, the user can perform a regular action.
       * If the mode is Unlimited, it always returns null.
       */
      nextActionDate?: string;
      /** @description The regularity displayed in the configuration, if the user chooses the cumulative or non-cumulative mode. If you enable only Unlimited mode, you don't need to fill this parameter. */
      regularity: number;
      /**
       * @description An extension can offer different modes, depending on the way it works and the actions to be performed. An action is a user interaction, for example in Chaster extensions, spinning the wheel of fortune, assigning a task, or checking in. The frequency of the actions can be defined and limited according to the mode chosen by the user among the modes offered by the extension.
       *
       * More information: https://docs.chaster.app/api/extensions-api/configuration#available-modes
       * @enum {string}
       */
      mode: "cumulative" | "non_cumulative" | "turn" | "unlimited";
    };
    SubmitRegularActionDto: {
      /**
       * @description The payload of the regular action, in a key-value object format. You can
       * store any data you want in this object, and retrieve it later when fetching
       * the list of previous regular actions.
       */
      payload: Record<string, never>;
    };
    SubmitRegularActionErrorDto: {
      message: string;
      /**
       * @description The number of regular actions remaining. If the mode is Unlimited, it returns -1.
       *
       * Use it to display the number of actions remaining to the user, and know when the user can perform a regular action.
       * If the value is 0, the user cannot perform a regular action.
       */
      nbActionsRemaining: number;
      /**
       * @description The date when the next regular action can be performed.
       *
       * Use it to compare the current date with the next action date to know when the user can perform a regular action.
       * If the value is null, the user can perform a regular action.
       * If the mode is Unlimited, it always returns null.
       */
      nextActionDate?: string;
      /** @description The regularity displayed in the configuration, if the user chooses the cumulative or non-cumulative mode. If you enable only Unlimited mode, you don't need to fill this parameter. */
      regularity: number;
      /**
       * @description An extension can offer different modes, depending on the way it works and the actions to be performed. An action is a user interaction, for example in Chaster extensions, spinning the wheel of fortune, assigning a task, or checking in. The frequency of the actions can be defined and limited according to the mode chosen by the user among the modes offered by the extension.
       *
       * More information: https://docs.chaster.app/api/extensions-api/configuration#available-modes
       * @enum {string}
       */
      mode: "cumulative" | "non_cumulative" | "turn" | "unlimited";
    };
    /** @enum {string} */
    ActionLogRoleEnum: "user" | "keyholder" | "extension" | "admin";
    PartnerCustomLogActionDto: {
      /**
       * @description The user type who initiated the action.
       *
       * It can be either the wearer or the keyholder, or the extension itself.
       */
      role?: components["schemas"]["ActionLogRoleEnum"];
      /**
       * @description The FontAwesome icon, without the `fa-` prefix.
       *
       * The icon must be part of the FontAwesome v5 regular icons:
       * https://fontawesome.com/v5/search?o=r&s=regular
       * @enum {string|null}
       */
      icon?: "abacus" | "acorn" | "ad" | "address-book" | "address-card" | "adjust" | "air-conditioner" | "air-freshener" | "alarm-clock" | "alarm-exclamation" | "alarm-plus" | "alarm-snooze" | "album-collection" | "album" | "alicorn" | "alien-monster" | "alien" | "align-center" | "align-justify" | "align-left" | "align-right" | "align-slash" | "allergies" | "ambulance" | "american-sign-language-interpreting" | "amp-guitar" | "analytics" | "anchor" | "angel" | "angle-double-down" | "angle-double-left" | "angle-double-right" | "angle-double-up" | "angle-down" | "angle-left" | "angle-right" | "angle-up" | "angry" | "ankh" | "apple-alt" | "apple-crate" | "archive" | "archway" | "arrow-alt-circle-down" | "arrow-alt-circle-left" | "arrow-alt-circle-right" | "arrow-alt-circle-up" | "arrow-alt-down" | "arrow-alt-from-bottom" | "arrow-alt-from-left" | "arrow-alt-from-right" | "arrow-alt-from-top" | "arrow-alt-left" | "arrow-alt-right" | "arrow-alt-square-down" | "arrow-alt-square-left" | "arrow-alt-square-right" | "arrow-alt-square-up" | "arrow-alt-to-bottom" | "arrow-alt-to-left" | "arrow-alt-to-right" | "arrow-alt-to-top" | "arrow-alt-up" | "arrow-circle-down" | "arrow-circle-left" | "arrow-circle-right" | "arrow-circle-up" | "arrow-down" | "arrow-from-bottom" | "arrow-from-left" | "arrow-from-right" | "arrow-from-top" | "arrow-left" | "arrow-right" | "arrow-square-down" | "arrow-square-left" | "arrow-square-right" | "arrow-square-up" | "arrow-to-bottom" | "arrow-to-left" | "arrow-to-right" | "arrow-to-top" | "arrow-up" | "arrows-alt-h" | "arrows-alt-v" | "arrows-alt" | "arrows-h" | "arrows-v" | "arrows" | "assistive-listening-systems" | "asterisk" | "at" | "atlas" | "atom-alt" | "atom" | "audio-description" | "award" | "axe-battle" | "axe" | "baby-carriage" | "baby" | "backpack" | "backspace" | "backward" | "bacon" | "bacteria" | "bacterium" | "badge-check" | "badge-dollar" | "badge-percent" | "badge-sheriff" | "badge" | "badger-honey" | "bags-shopping" | "bahai" | "balance-scale-left" | "balance-scale-right" | "balance-scale" | "ball-pile" | "ballot-check" | "ballot" | "ban" | "band-aid" | "banjo" | "barcode-alt" | "barcode-read" | "barcode-scan" | "barcode" | "bars" | "baseball-ball" | "baseball" | "basketball-ball" | "basketball-hoop" | "bat" | "bath" | "battery-bolt" | "battery-empty" | "battery-full" | "battery-half" | "battery-quarter" | "battery-slash" | "battery-three-quarters" | "bed-alt" | "bed-bunk" | "bed-empty" | "bed" | "beer" | "bell-exclamation" | "bell-on" | "bell-plus" | "bell-school-slash" | "bell-school" | "bell-slash" | "bell" | "bells" | "betamax" | "bezier-curve" | "bible" | "bicycle" | "biking-mountain" | "biking" | "binoculars" | "biohazard" | "birthday-cake" | "blanket" | "blender-phone" | "blender" | "blind" | "blinds-open" | "blinds-raised" | "blinds" | "blog" | "bold" | "bolt" | "bomb" | "bone-break" | "bone" | "bong" | "book-alt" | "book-dead" | "book-heart" | "book-medical" | "book-open" | "book-reader" | "book-spells" | "book-user" | "book" | "bookmark" | "books-medical" | "books" | "boombox" | "boot" | "booth-curtain" | "border-all" | "border-bottom" | "border-center-h" | "border-center-v" | "border-inner" | "border-left" | "border-none" | "border-outer" | "border-right" | "border-style-alt" | "border-style" | "border-top" | "bow-arrow" | "bowling-ball" | "bowling-pins" | "box-alt" | "box-ballot" | "box-check" | "box-fragile" | "box-full" | "box-heart" | "box-open" | "box-tissue" | "box-up" | "box-usd" | "box" | "boxes-alt" | "boxes" | "boxing-glove" | "brackets-curly" | "brackets" | "braille" | "brain" | "bread-loaf" | "bread-slice" | "briefcase-medical" | "briefcase" | "bring-forward" | "bring-front" | "broadcast-tower" | "broom" | "browser" | "brush" | "bug" | "building" | "bullhorn" | "bullseye-arrow" | "bullseye-pointer" | "bullseye" | "burger-soda" | "burn" | "burrito" | "bus-alt" | "bus-school" | "bus" | "business-time" | "cabinet-filing" | "cactus" | "calculator-alt" | "calculator" | "calendar-alt" | "calendar-check" | "calendar-day" | "calendar-edit" | "calendar-exclamation" | "calendar-minus" | "calendar-plus" | "calendar-star" | "calendar-times" | "calendar-week" | "calendar" | "camcorder" | "camera-alt" | "camera-home" | "camera-movie" | "camera-polaroid" | "camera-retro" | "camera" | "campfire" | "campground" | "candle-holder" | "candy-cane" | "candy-corn" | "cannabis" | "capsules" | "car-alt" | "car-battery" | "car-building" | "car-bump" | "car-bus" | "car-crash" | "car-garage" | "car-mechanic" | "car-side" | "car-tilt" | "car-wash" | "car" | "caravan-alt" | "caravan" | "caret-circle-down" | "caret-circle-left" | "caret-circle-right" | "caret-circle-up" | "caret-down" | "caret-left" | "caret-right" | "caret-square-down" | "caret-square-left" | "caret-square-right" | "caret-square-up" | "caret-up" | "carrot" | "cars" | "cart-arrow-down" | "cart-plus" | "cash-register" | "cassette-tape" | "cat-space" | "cat" | "cauldron" | "cctv" | "certificate" | "chair-office" | "chair" | "chalkboard-teacher" | "chalkboard" | "charging-station" | "chart-area" | "chart-bar" | "chart-line-down" | "chart-line" | "chart-network" | "chart-pie-alt" | "chart-pie" | "chart-scatter" | "check-circle" | "check-double" | "check-square" | "check" | "cheese-swiss" | "cheese" | "cheeseburger" | "chess-bishop-alt" | "chess-bishop" | "chess-board" | "chess-clock-alt" | "chess-clock" | "chess-king-alt" | "chess-king" | "chess-knight-alt" | "chess-knight" | "chess-pawn-alt" | "chess-pawn" | "chess-queen-alt" | "chess-queen" | "chess-rook-alt" | "chess-rook" | "chess" | "chevron-circle-down" | "chevron-circle-left" | "chevron-circle-right" | "chevron-circle-up" | "chevron-double-down" | "chevron-double-left" | "chevron-double-right" | "chevron-double-up" | "chevron-down" | "chevron-left" | "chevron-right" | "chevron-square-down" | "chevron-square-left" | "chevron-square-right" | "chevron-square-up" | "chevron-up" | "child" | "chimney" | "church" | "circle-notch" | "circle" | "city" | "clarinet" | "claw-marks" | "clinic-medical" | "clipboard-check" | "clipboard-list-check" | "clipboard-list" | "clipboard-prescription" | "clipboard-user" | "clipboard" | "clock" | "clone" | "closed-captioning" | "cloud-download-alt" | "cloud-download" | "cloud-drizzle" | "cloud-hail-mixed" | "cloud-hail" | "cloud-meatball" | "cloud-moon-rain" | "cloud-moon" | "cloud-music" | "cloud-rain" | "cloud-rainbow" | "cloud-showers-heavy" | "cloud-showers" | "cloud-sleet" | "cloud-snow" | "cloud-sun-rain" | "cloud-sun" | "cloud-upload-alt" | "cloud-upload" | "cloud" | "clouds-moon" | "clouds-sun" | "clouds" | "club" | "cocktail" | "code-branch" | "code-commit" | "code-merge" | "code" | "coffee-pot" | "coffee-togo" | "coffee" | "coffin-cross" | "coffin" | "cog" | "cogs" | "coin" | "coins" | "columns" | "comet" | "comment-alt-check" | "comment-alt-dollar" | "comment-alt-dots" | "comment-alt-edit" | "comment-alt-exclamation" | "comment-alt-lines" | "comment-alt-medical" | "comment-alt-minus" | "comment-alt-music" | "comment-alt-plus" | "comment-alt-slash" | "comment-alt-smile" | "comment-alt-times" | "comment-alt" | "comment-check" | "comment-dollar" | "comment-dots" | "comment-edit" | "comment-exclamation" | "comment-lines" | "comment-medical" | "comment-minus" | "comment-music" | "comment-plus" | "comment-slash" | "comment-smile" | "comment-times" | "comment" | "comments-alt-dollar" | "comments-alt" | "comments-dollar" | "comments" | "compact-disc" | "compass-slash" | "compass" | "compress-alt" | "compress-arrows-alt" | "compress-wide" | "compress" | "computer-classic" | "computer-speaker" | "concierge-bell" | "construction" | "container-storage" | "conveyor-belt-alt" | "conveyor-belt" | "cookie-bite" | "cookie" | "copy" | "copyright" | "corn" | "couch" | "cow" | "cowbell-more" | "cowbell" | "credit-card-blank" | "credit-card-front" | "credit-card" | "cricket" | "croissant" | "crop-alt" | "crop" | "cross" | "crosshairs" | "crow" | "crown" | "crutch" | "crutches" | "cube" | "cubes" | "curling" | "cut" | "dagger" | "database" | "deaf" | "debug" | "deer-rudolph" | "deer" | "democrat" | "desktop-alt" | "desktop" | "dewpoint" | "dharmachakra" | "diagnoses" | "diamond" | "dice-d10" | "dice-d12" | "dice-d20" | "dice-d4" | "dice-d6" | "dice-d8" | "dice-five" | "dice-four" | "dice-one" | "dice-six" | "dice-three" | "dice-two" | "dice" | "digging" | "digital-tachograph" | "diploma" | "directions" | "disc-drive" | "disease" | "divide" | "dizzy" | "dna" | "do-not-enter" | "dog-leashed" | "dog" | "dollar-sign" | "dolly-empty" | "dolly-flatbed-alt" | "dolly-flatbed-empty" | "dolly-flatbed" | "dolly" | "donate" | "door-closed" | "door-open" | "dot-circle" | "dove" | "download" | "drafting-compass" | "dragon" | "draw-circle" | "draw-polygon" | "draw-square" | "dreidel" | "drone-alt" | "drone" | "drum-steelpan" | "drum" | "drumstick-bite" | "drumstick" | "dryer-alt" | "dryer" | "duck" | "dumbbell" | "dumpster-fire" | "dumpster" | "dungeon" | "ear-muffs" | "ear" | "eclipse-alt" | "eclipse" | "edit" | "egg-fried" | "egg" | "eject" | "elephant" | "ellipsis-h-alt" | "ellipsis-h" | "ellipsis-v-alt" | "ellipsis-v" | "empty-set" | "engine-warning" | "envelope-open-dollar" | "envelope-open-text" | "envelope-open" | "envelope-square" | "envelope" | "equals" | "eraser" | "ethernet" | "euro-sign" | "exchange-alt" | "exchange" | "exclamation-circle" | "exclamation-square" | "exclamation-triangle" | "exclamation" | "expand-alt" | "expand-arrows-alt" | "expand-arrows" | "expand-wide" | "expand" | "external-link-alt" | "external-link-square-alt" | "external-link-square" | "external-link" | "eye-dropper" | "eye-evil" | "eye-slash" | "eye" | "fan-table" | "fan" | "farm" | "fast-backward" | "fast-forward" | "faucet-drip" | "faucet" | "fax" | "feather-alt" | "feather" | "female" | "field-hockey" | "fighter-jet" | "file-alt" | "file-archive" | "file-audio" | "file-certificate" | "file-chart-line" | "file-chart-pie" | "file-check" | "file-code" | "file-contract" | "file-csv" | "file-download" | "file-edit" | "file-excel" | "file-exclamation" | "file-export" | "file-image" | "file-import" | "file-invoice-dollar" | "file-invoice" | "file-medical-alt" | "file-medical" | "file-minus" | "file-music" | "file-pdf" | "file-plus" | "file-powerpoint" | "file-prescription" | "file-search" | "file-signature" | "file-spreadsheet" | "file-times" | "file-upload" | "file-user" | "file-video" | "file-word" | "file" | "files-medical" | "fill-drip" | "fill" | "film-alt" | "film-canister" | "film" | "filter" | "fingerprint" | "fire-alt" | "fire-extinguisher" | "fire-smoke" | "fire" | "fireplace" | "first-aid" | "fish-cooked" | "fish" | "fist-raised" | "flag-alt" | "flag-checkered" | "flag-usa" | "flag" | "flame" | "flashlight" | "flask-poison" | "flask-potion" | "flask" | "flower-daffodil" | "flower-tulip" | "flower" | "flushed" | "flute" | "flux-capacitor" | "fog" | "folder-download" | "folder-minus" | "folder-open" | "folder-plus" | "folder-times" | "folder-tree" | "folder-upload" | "folder" | "folders" | "font-awesome-logo-full" | "font-case" | "font" | "football-ball" | "football-helmet" | "forklift" | "forward" | "fragile" | "french-fries" | "frog" | "frosty-head" | "frown-open" | "frown" | "function" | "funnel-dollar" | "futbol" | "galaxy" | "game-board-alt" | "game-board" | "game-console-handheld" | "gamepad-alt" | "gamepad" | "garage-car" | "garage-open" | "garage" | "gas-pump-slash" | "gas-pump" | "gavel" | "gem" | "genderless" | "ghost" | "gift-card" | "gift" | "gifts" | "gingerbread-man" | "glass-champagne" | "glass-cheers" | "glass-citrus" | "glass-martini-alt" | "glass-martini" | "glass-whiskey-rocks" | "glass-whiskey" | "glass" | "glasses-alt" | "glasses" | "globe-africa" | "globe-americas" | "globe-asia" | "globe-europe" | "globe-snow" | "globe-stand" | "globe" | "golf-ball" | "golf-club" | "gopuram" | "graduation-cap" | "gramophone" | "greater-than-equal" | "greater-than" | "grimace" | "grin-alt" | "grin-beam-sweat" | "grin-beam" | "grin-hearts" | "grin-squint-tears" | "grin-squint" | "grin-stars" | "grin-tears" | "grin-tongue-squint" | "grin-tongue-wink" | "grin-tongue" | "grin-wink" | "grin" | "grip-horizontal" | "grip-lines-vertical" | "grip-lines" | "grip-vertical" | "guitar-electric" | "guitar" | "guitars" | "h-square" | "h1" | "h2" | "h3" | "h4" | "hamburger" | "hammer-war" | "hammer" | "hamsa" | "hand-heart" | "hand-holding-box" | "hand-holding-heart" | "hand-holding-magic" | "hand-holding-medical" | "hand-holding-seedling" | "hand-holding-usd" | "hand-holding-water" | "hand-holding" | "hand-lizard" | "hand-middle-finger" | "hand-paper" | "hand-peace" | "hand-point-down" | "hand-point-left" | "hand-point-right" | "hand-point-up" | "hand-pointer" | "hand-receiving" | "hand-rock" | "hand-scissors" | "hand-sparkles" | "hand-spock" | "hands-heart" | "hands-helping" | "hands-usd" | "hands-wash" | "hands" | "handshake-alt-slash" | "handshake-alt" | "handshake-slash" | "handshake" | "hanukiah" | "hard-hat" | "hashtag" | "hat-chef" | "hat-cowboy-side" | "hat-cowboy" | "hat-santa" | "hat-winter" | "hat-witch" | "hat-wizard" | "hdd" | "head-side-brain" | "head-side-cough-slash" | "head-side-cough" | "head-side-headphones" | "head-side-mask" | "head-side-medical" | "head-side-virus" | "head-side" | "head-vr" | "heading" | "headphones-alt" | "headphones" | "headset" | "heart-broken" | "heart-circle" | "heart-rate" | "heart-square" | "heart" | "heartbeat" | "heat" | "helicopter" | "helmet-battle" | "hexagon" | "highlighter" | "hiking" | "hippo" | "history" | "hockey-mask" | "hockey-puck" | "hockey-sticks" | "holly-berry" | "home-alt" | "home-heart" | "home-lg-alt" | "home-lg" | "home" | "hood-cloak" | "horizontal-rule" | "horse-head" | "horse-saddle" | "horse" | "hospital-alt" | "hospital-symbol" | "hospital-user" | "hospital" | "hospitals" | "hot-tub" | "hotdog" | "hotel" | "hourglass-end" | "hourglass-half" | "hourglass-start" | "hourglass" | "house-damage" | "house-day" | "house-flood" | "house-leave" | "house-night" | "house-return" | "house-signal" | "house-user" | "house" | "hryvnia" | "humidity" | "hurricane" | "i-cursor" | "ice-cream" | "ice-skate" | "icicles" | "icons-alt" | "icons" | "id-badge" | "id-card-alt" | "id-card" | "igloo" | "image-polaroid" | "image" | "images" | "inbox-in" | "inbox-out" | "inbox" | "indent" | "industry-alt" | "industry" | "infinity" | "info-circle" | "info-square" | "info" | "inhaler" | "integral" | "intersection" | "inventory" | "island-tropical" | "italic" | "jack-o-lantern" | "jedi" | "joint" | "journal-whills" | "joystick" | "jug" | "kaaba" | "kazoo" | "kerning" | "key-skeleton" | "key" | "keyboard" | "keynote" | "khanda" | "kidneys" | "kiss-beam" | "kiss-wink-heart" | "kiss" | "kite" | "kiwi-bird" | "knife-kitchen" | "lambda" | "lamp-desk" | "lamp-floor" | "lamp" | "landmark-alt" | "landmark" | "language" | "laptop-code" | "laptop-house" | "laptop-medical" | "laptop" | "lasso" | "laugh-beam" | "laugh-squint" | "laugh-wink" | "laugh" | "layer-group" | "layer-minus" | "layer-plus" | "leaf-heart" | "leaf-maple" | "leaf-oak" | "leaf" | "lemon" | "less-than-equal" | "less-than" | "level-down-alt" | "level-down" | "level-up-alt" | "level-up" | "life-ring" | "light-ceiling" | "light-switch-off" | "light-switch-on" | "light-switch" | "lightbulb-dollar" | "lightbulb-exclamation" | "lightbulb-on" | "lightbulb-slash" | "lightbulb" | "lights-holiday" | "line-columns" | "line-height" | "link" | "lips" | "lira-sign" | "list-alt" | "list-music" | "list-ol" | "list-ul" | "list" | "location-arrow" | "location-circle" | "location-slash" | "location" | "lock-alt" | "lock-open-alt" | "lock-open" | "lock" | "long-arrow-alt-down" | "long-arrow-alt-left" | "long-arrow-alt-right" | "long-arrow-alt-up" | "long-arrow-down" | "long-arrow-left" | "long-arrow-right" | "long-arrow-up" | "loveseat" | "low-vision" | "luchador" | "luggage-cart" | "lungs-virus" | "lungs" | "mace" | "magic" | "magnet" | "mail-bulk" | "mailbox" | "male" | "mandolin" | "map-marked-alt" | "map-marked" | "map-marker-alt-slash" | "map-marker-alt" | "map-marker-check" | "map-marker-edit" | "map-marker-exclamation" | "map-marker-minus" | "map-marker-plus" | "map-marker-question" | "map-marker-slash" | "map-marker-smile" | "map-marker-times" | "map-marker" | "map-pin" | "map-signs" | "map" | "marker" | "mars-double" | "mars-stroke-h" | "mars-stroke-v" | "mars-stroke" | "mars" | "mask" | "meat" | "medal" | "medkit" | "megaphone" | "meh-blank" | "meh-rolling-eyes" | "meh" | "memory" | "menorah" | "mercury" | "meteor" | "microchip" | "microphone-alt-slash" | "microphone-alt" | "microphone-slash" | "microphone-stand" | "microphone" | "microscope" | "microwave" | "mind-share" | "minus-circle" | "minus-hexagon" | "minus-octagon" | "minus-square" | "minus" | "mistletoe" | "mitten" | "mobile-alt" | "mobile-android-alt" | "mobile-android" | "mobile" | "money-bill-alt" | "money-bill-wave-alt" | "money-bill-wave" | "money-bill" | "money-check-alt" | "money-check-edit-alt" | "money-check-edit" | "money-check" | "monitor-heart-rate" | "monkey" | "monument" | "moon-cloud" | "moon-stars" | "moon" | "mortar-pestle" | "mosque" | "motorcycle" | "mountain" | "mountains" | "mouse-alt" | "mouse-pointer" | "mouse" | "mp3-player" | "mug-hot" | "mug-marshmallows" | "mug-tea" | "mug" | "music-alt-slash" | "music-alt" | "music-slash" | "music" | "narwhal" | "network-wired" | "neuter" | "newspaper" | "not-equal" | "notes-medical" | "object-group" | "object-ungroup" | "octagon" | "oil-can" | "oil-temp" | "om" | "omega" | "ornament" | "otter" | "outdent" | "outlet" | "oven" | "overline" | "page-break" | "pager" | "paint-brush-alt" | "paint-brush" | "paint-roller" | "palette" | "pallet-alt" | "pallet" | "paper-plane" | "paperclip" | "parachute-box" | "paragraph-rtl" | "paragraph" | "parking-circle-slash" | "parking-circle" | "parking-slash" | "parking" | "passport" | "pastafarianism" | "paste" | "pause-circle" | "pause" | "paw-alt" | "paw-claws" | "paw" | "peace" | "pegasus" | "pen-alt" | "pen-fancy" | "pen-nib" | "pen-square" | "pen" | "pencil-alt" | "pencil-paintbrush" | "pencil-ruler" | "pencil" | "pennant" | "people-arrows" | "people-carry" | "pepper-hot" | "percent" | "percentage" | "person-booth" | "person-carry" | "person-dolly-empty" | "person-dolly" | "person-sign" | "phone-alt" | "phone-laptop" | "phone-office" | "phone-plus" | "phone-rotary" | "phone-slash" | "phone-square-alt" | "phone-square" | "phone-volume" | "phone" | "photo-video" | "pi" | "piano-keyboard" | "piano" | "pie" | "pig" | "piggy-bank" | "pills" | "pizza-slice" | "pizza" | "place-of-worship" | "plane-alt" | "plane-arrival" | "plane-departure" | "plane-slash" | "plane" | "planet-moon" | "planet-ringed" | "play-circle" | "play" | "plug" | "plus-circle" | "plus-hexagon" | "plus-octagon" | "plus-square" | "plus" | "podcast" | "podium-star" | "podium" | "police-box" | "poll-h" | "poll-people" | "poll" | "poo-storm" | "poo" | "poop" | "popcorn" | "portal-enter" | "portal-exit" | "portrait" | "pound-sign" | "power-off" | "pray" | "praying-hands" | "prescription-bottle-alt" | "prescription-bottle" | "prescription" | "presentation" | "print-search" | "print-slash" | "print" | "procedures" | "project-diagram" | "projector" | "pump-medical" | "pump-soap" | "pumpkin" | "puzzle-piece" | "qrcode" | "question-circle" | "question-square" | "question" | "quidditch" | "quote-left" | "quote-right" | "quran" | "rabbit-fast" | "rabbit" | "racquet" | "radar" | "radiation-alt" | "radiation" | "radio-alt" | "radio" | "rainbow" | "raindrops" | "ram" | "ramp-loading" | "random" | "raygun" | "receipt" | "record-vinyl" | "rectangle-landscape" | "rectangle-portrait" | "rectangle-wide" | "recycle" | "redo-alt" | "redo" | "refrigerator" | "registered" | "remove-format" | "repeat-1-alt" | "repeat-1" | "repeat-alt" | "repeat" | "reply-all" | "reply" | "republican" | "restroom" | "retweet-alt" | "retweet" | "ribbon" | "ring" | "rings-wedding" | "road" | "robot" | "rocket-launch" | "rocket" | "route-highway" | "route-interstate" | "route" | "router" | "rss-square" | "rss" | "ruble-sign" | "ruler-combined" | "ruler-horizontal" | "ruler-triangle" | "ruler-vertical" | "ruler" | "running" | "rupee-sign" | "rv" | "sack-dollar" | "sack" | "sad-cry" | "sad-tear" | "salad" | "sandwich" | "satellite-dish" | "satellite" | "sausage" | "save" | "sax-hot" | "saxophone" | "scalpel-path" | "scalpel" | "scanner-image" | "scanner-keyboard" | "scanner-touchscreen" | "scanner" | "scarecrow" | "scarf" | "school" | "screwdriver" | "scroll-old" | "scroll" | "scrubber" | "scythe" | "sd-card" | "search-dollar" | "search-location" | "search-minus" | "search-plus" | "search" | "seedling" | "send-back" | "send-backward" | "sensor-alert" | "sensor-fire" | "sensor-on" | "sensor-smoke" | "sensor" | "server" | "shapes" | "share-all" | "share-alt-square" | "share-alt" | "share-square" | "share" | "sheep" | "shekel-sign" | "shield-alt" | "shield-check" | "shield-cross" | "shield-virus" | "shield" | "ship" | "shipping-fast" | "shipping-timed" | "shish-kebab" | "shoe-prints" | "shopping-bag" | "shopping-basket" | "shopping-cart" | "shovel-snow" | "shovel" | "shower" | "shredder" | "shuttle-van" | "shuttlecock" | "sickle" | "sigma" | "sign-in-alt" | "sign-in" | "sign-language" | "sign-out-alt" | "sign-out" | "sign" | "signal-1" | "signal-2" | "signal-3" | "signal-4" | "signal-alt-1" | "signal-alt-2" | "signal-alt-3" | "signal-alt-slash" | "signal-alt" | "signal-slash" | "signal-stream" | "signal" | "signature" | "sim-card" | "sink" | "siren-on" | "siren" | "sitemap" | "skating" | "skeleton" | "ski-jump" | "ski-lift" | "skiing-nordic" | "skiing" | "skull-cow" | "skull-crossbones" | "skull" | "slash" | "sledding" | "sleigh" | "sliders-h-square" | "sliders-h" | "sliders-v-square" | "sliders-v" | "smile-beam" | "smile-plus" | "smile-wink" | "smile" | "smog" | "smoke" | "smoking-ban" | "smoking" | "sms" | "snake" | "snooze" | "snow-blowing" | "snowboarding" | "snowflake" | "snowflakes" | "snowman" | "snowmobile" | "snowplow" | "soap" | "socks" | "solar-panel" | "solar-system" | "sort-alpha-down-alt" | "sort-alpha-down" | "sort-alpha-up-alt" | "sort-alpha-up" | "sort-alt" | "sort-amount-down-alt" | "sort-amount-down" | "sort-amount-up-alt" | "sort-amount-up" | "sort-circle-down" | "sort-circle-up" | "sort-circle" | "sort-down" | "sort-numeric-down-alt" | "sort-numeric-down" | "sort-numeric-up-alt" | "sort-numeric-up" | "sort-shapes-down-alt" | "sort-shapes-down" | "sort-shapes-up-alt" | "sort-shapes-up" | "sort-size-down-alt" | "sort-size-down" | "sort-size-up-alt" | "sort-size-up" | "sort-up" | "sort" | "soup" | "spa" | "space-shuttle" | "space-station-moon-alt" | "space-station-moon" | "spade" | "sparkles" | "speaker" | "speakers" | "spell-check" | "spider-black-widow" | "spider-web" | "spider" | "spinner-third" | "spinner" | "splotch" | "spray-can" | "sprinkler" | "square-full" | "square-root-alt" | "square-root" | "square" | "squirrel" | "staff" | "stamp" | "star-and-crescent" | "star-christmas" | "star-exclamation" | "star-half-alt" | "star-half" | "star-of-david" | "star-of-life" | "star-shooting" | "star" | "starfighter-alt" | "starfighter" | "stars" | "starship-freighter" | "starship" | "steak" | "steering-wheel" | "step-backward" | "step-forward" | "stethoscope" | "sticky-note" | "stocking" | "stomach" | "stop-circle" | "stop" | "stopwatch-20" | "stopwatch" | "store-alt-slash" | "store-alt" | "store-slash" | "store" | "stream" | "street-view" | "stretcher" | "strikethrough" | "stroopwafel" | "subscript" | "subway" | "suitcase-rolling" | "suitcase" | "sun-cloud" | "sun-dust" | "sun-haze" | "sun" | "sunglasses" | "sunrise" | "sunset" | "superscript" | "surprise" | "swatchbook" | "swimmer" | "swimming-pool" | "sword-laser-alt" | "sword-laser" | "sword" | "swords-laser" | "swords" | "synagogue" | "sync-alt" | "sync" | "syringe" | "t" | "table-tennis" | "table" | "tablet-alt" | "tablet-android-alt" | "tablet-android" | "tablet-rugged" | "tablet" | "tablets" | "tachometer-alt-average" | "tachometer-alt-fast" | "tachometer-alt-fastest" | "tachometer-alt-slow" | "tachometer-alt-slowest" | "tachometer-alt" | "tachometer-average" | "tachometer-fast" | "tachometer-fastest" | "tachometer-slow" | "tachometer-slowest" | "tachometer" | "taco" | "tag" | "tags" | "tally" | "tanakh" | "tape" | "tasks-alt" | "tasks" | "taxi" | "teeth-open" | "teeth" | "telescope" | "temperature-down" | "temperature-frigid" | "temperature-high" | "temperature-hot" | "temperature-low" | "temperature-up" | "tenge" | "tennis-ball" | "terminal" | "text-height" | "text-size" | "text-width" | "text" | "th-large" | "th-list" | "th" | "theater-masks" | "thermometer-empty" | "thermometer-full" | "thermometer-half" | "thermometer-quarter" | "thermometer-three-quarters" | "thermometer" | "theta" | "thumbs-down" | "thumbs-up" | "thumbtack" | "thunderstorm-moon" | "thunderstorm-sun" | "thunderstorm" | "ticket-alt" | "ticket" | "tilde" | "times-circle" | "times-hexagon" | "times-octagon" | "times-square" | "times" | "tint-slash" | "tint" | "tire-flat" | "tire-pressure-warning" | "tire-rugged" | "tire" | "tired" | "toggle-off" | "toggle-on" | "toilet-paper-alt" | "toilet-paper-slash" | "toilet-paper" | "toilet" | "tombstone-alt" | "tombstone" | "toolbox" | "tools" | "tooth" | "toothbrush" | "torah" | "torii-gate" | "tornado" | "tractor" | "trademark" | "traffic-cone" | "traffic-light-go" | "traffic-light-slow" | "traffic-light-stop" | "traffic-light" | "trailer" | "train" | "tram" | "transgender-alt" | "transgender" | "transporter-1" | "transporter-2" | "transporter-3" | "transporter-empty" | "transporter" | "trash-alt" | "trash-restore-alt" | "trash-restore" | "trash-undo-alt" | "trash-undo" | "trash" | "treasure-chest" | "tree-alt" | "tree-christmas" | "tree-decorated" | "tree-large" | "tree-palm" | "tree" | "trees" | "triangle-music" | "triangle" | "trophy-alt" | "trophy" | "truck-container" | "truck-couch" | "truck-loading" | "truck-monster" | "truck-moving" | "truck-pickup" | "truck-plow" | "truck-ramp" | "truck" | "trumpet" | "tshirt" | "tty" | "turkey" | "turntable" | "turtle" | "tv-alt" | "tv-music" | "tv-retro" | "tv" | "typewriter" | "ufo-beam" | "ufo" | "umbrella-beach" | "umbrella" | "underline" | "undo-alt" | "undo" | "unicorn" | "union" | "universal-access" | "university" | "unlink" | "unlock-alt" | "unlock" | "upload" | "usb-drive" | "usd-circle" | "usd-square" | "user-alien" | "user-alt-slash" | "user-alt" | "user-astronaut" | "user-chart" | "user-check" | "user-circle" | "user-clock" | "user-cog" | "user-cowboy" | "user-crown" | "user-edit" | "user-friends" | "user-graduate" | "user-hard-hat" | "user-headset" | "user-injured" | "user-lock" | "user-md-chat" | "user-md" | "user-minus" | "user-music" | "user-ninja" | "user-nurse" | "user-plus" | "user-robot" | "user-secret" | "user-shield" | "user-slash" | "user-tag" | "user-tie" | "user-times" | "user-unlock" | "user-visor" | "user" | "users-class" | "users-cog" | "users-crown" | "users-medical" | "users-slash" | "users" | "utensil-fork" | "utensil-knife" | "utensil-spoon" | "utensils-alt" | "utensils" | "vacuum-robot" | "vacuum" | "value-absolute" | "vector-square" | "venus-double" | "venus-mars" | "venus" | "vest-patches" | "vest" | "vhs" | "vial" | "vials" | "video-plus" | "video-slash" | "video" | "vihara" | "violin" | "virus-slash" | "virus" | "viruses" | "voicemail" | "volcano" | "volleyball-ball" | "volume-down" | "volume-mute" | "volume-off" | "volume-slash" | "volume-up" | "volume" | "vote-nay" | "vote-yea" | "vr-cardboard" | "wagon-covered" | "walker" | "walkie-talkie" | "walking" | "wallet" | "wand-magic" | "wand" | "warehouse-alt" | "warehouse" | "washer" | "watch-calculator" | "watch-fitness" | "watch" | "water-lower" | "water-rise" | "water" | "wave-sine" | "wave-square" | "wave-triangle" | "waveform-path" | "waveform" | "webcam-slash" | "webcam" | "weight-hanging" | "weight" | "whale" | "wheat" | "wheelchair" | "whistle" | "wifi-1" | "wifi-2" | "wifi-slash" | "wifi" | "wind-turbine" | "wind-warning" | "wind" | "window-alt" | "window-close" | "window-frame-open" | "window-frame" | "window-maximize" | "window-minimize" | "window-restore" | "window" | "windsock" | "wine-bottle" | "wine-glass-alt" | "wine-glass" | "won-sign" | "wreath" | "wrench" | "x-ray" | "yen-sign" | "yin-yang" | null;
      /** @description The color of the log action. */
      color?: string | null;
      /** @description The log action title */
      title: string;
      /** @description The log action description */
      description: string;
    };
    SetSessionDataDto: {
      /** @description Data stored for this session, in a key-value format. */
      data: Record<string, never>;
    };
    PartnerConfigurationForPublic: {
      /** @description The configuration object */
      config: Record<string, never>;
      /** @description The user who created the configuration */
      user: string;
      /** @description If provided, the user is editing a configuration for an existing extension session. This is the session ID. */
      sessionId: string | null;
      /** @description The extension slug */
      extensionSlug: string;
      /**
       * Format: date-time
       * @description Created at
       */
      createdAt: string;
    };
    UpdatePartnerConfigurationDto: {
      /** @description The configuration object */
      config: Record<string, never>;
    };
    CommunityEventTier: {
      name: string;
      requiredPoints: number;
    };
    CommunityEventSettings: {
      /** @description Whether the community event is enabled */
      enabled: boolean;
      /** @description The community event slug */
      slug: string;
      /** @description The community event name */
      name: string;
      /** @description The community event color */
      color: string;
      /** @description The community event light color */
      lightColor: string;
      /** @description The community event icon */
      icon: string;
      /** @description The community event tiers */
      tiers: components["schemas"]["CommunityEventTier"][];
    };
    AppSettingsDto: {
      /** @description Global features */
      features: components["schemas"]["FeatureSwitchEnum"][];
      /** @description The maximum number of locks allowed for a non-premium user */
      nonPremiumMaxLocks: number;
      /** @description The maximum number of extensions allowed for a non-premium user */
      nonPremiumMaxExtensions: number;
      /** @description Maximum number of attachments per upload */
      maxAttachments: number;
      /** @description True if the instance requires an access key */
      registerRequiresAccessKey: boolean;
      /** @description The recaptcha client key */
      recaptchaClientKey: string;
      /**
       * Format: date-time
       * @description The server time
       */
      time: string;
      /** @description The app version */
      version: string;
      /** @description Community event settings */
      communityEvent: components["schemas"]["CommunityEventSettings"] | null;
      /** @description Stripe public key */
      stripePublicKey: string;
      /** @description Vapid public key */
      vapidPublicKey: string;
    };
    /** @enum {string} */
    PartnerUserRoleEnum: "wearer" | "keyholder";
    PartnerGetSessionAuthRepDto: {
      role: components["schemas"]["PartnerUserRoleEnum"];
      session: components["schemas"]["ExtensionSessionForPartner"];
      lockForUser: components["schemas"]["LockForPublic"];
      userId: string;
    };
    /** @enum {string} */
    GenderEnum: "" | "agender" | "androgyne" | "androgynous" | "bigender" | "cis" | "cis-female" | "cis-male" | "cis-man" | "cis-woman" | "cisgender" | "cisgender-female" | "cisgender-male" | "cisgender-man" | "cisgender-woman" | "ftm" | "female" | "female-to-male" | "gender-fluid" | "gender-identity" | "gender-nonconforming" | "gender-questioning" | "gender-variant" | "genderqueer" | "intersex" | "mtf" | "male" | "male-to-female" | "neither" | "neutrois" | "non-binary" | "not-specified" | "other" | "pangender" | "trans" | "trans-female" | "trans-male" | "trans-man" | "trans-person" | "trans-woman" | "transfeminine" | "transgender" | "transgender-female" | "transgender-male" | "transgender-man" | "transgender-person" | "transgender-woman" | "transmasculine" | "transsexual" | "transsexual-female" | "transsexual-male" | "transsexual-man" | "transsexual-person" | "transsexual-woman" | "two-spirit";
    UserSettings: {
      showLocksOnProfile: boolean;
      showOnlineStatus: boolean;
      showDiscordOnProfile: boolean;
      emailOnWearerUsesSharedLock: boolean;
      messageOnWearerUsesSharedLock: boolean;
      discordNotifications: boolean;
      discordMessagingNotifications: boolean;
      displayNsfw: boolean;
      showAge: boolean;
    };
    Region: {
      name: string;
      shortCode?: string;
    };
    Country: {
      countryName: string;
      countryShortCode: string;
      regions?: components["schemas"]["Region"][];
    };
    UserSearchFormLocation: {
      countryShortCode: string | null;
      regionName: string | null;
    };
    UserSearchForm: {
      sexualOrientations?: components["schemas"]["SexualOrientationEnum"][];
      age?: number[];
      location?: components["schemas"]["UserSearchFormLocation"];
      wearer?: boolean;
      keyholder?: boolean;
      genders?: string[];
      hasFindom?: boolean;
      hasNotFindom?: boolean;
      isActive?: boolean;
    };
    PublicLockSearchForm: {
      hasFindom?: boolean;
      hasNotFindom?: boolean;
      user?: components["schemas"]["UserSearchForm"];
      duration?: components["schemas"]["DurationCriteriaData"];
      maxLimitDuration?: components["schemas"]["DurationCriteriaData"];
      extensions?: components["schemas"]["ExtensionCriteriaData"];
      /** @description Search locks by tags */
      tags?: string[];
      /**
       * @description Whether to match all tags
       * If true, return locks that contain all the tags
       * If false, return locks that contain at least one of the tags
       */
      matchAllTags?: boolean;
    };
    UserPrivateMetadataForPublic: {
      userSearchForm?: components["schemas"]["UserSearchForm"] | null;
      publicLockSearchForm?: components["schemas"]["PublicLockSearchForm"] | null;
    };
    CurrentUserForProfileSettings: {
      /** @description The gender */
      gender: components["schemas"]["GenderEnum"];
      /** @description The sexual orientation */
      sexualOrientation: components["schemas"]["SexualOrientationEnum"];
      /** @description The role */
      role: components["schemas"]["UserRoleEnum"];
      /** @description Enabled features */
      features: components["schemas"]["FeatureSwitchEnum"][];
      canEditUsername: boolean;
      email: string | null;
      /** @description The user Keycloak id */
      keycloakId: string;
      /** @description The username */
      username: string;
      /**
       * Format: date-time
       * @description End date of subscription
       */
      subscriptionEnd?: string | null;
      /**
       * Format: date-time
       * @description End date of custom subscription
       */
      customSubscriptionEnd?: string | null;
      /** @description Whether the subscription is past due */
      hasPastDueSubscription: boolean;
      /** @description The profile description */
      description: string;
      /** @description The location */
      location: string;
      /**
       * Format: date-time
       * @description The birth date
       */
      birthDate: string | null;
      /** @description Whether the email is verified */
      emailVerified: boolean;
      /** @description Whether the user is a developer */
      isDeveloper: boolean;
      /** @description Whether the user is a moderator */
      isModerator: boolean;
      /** @description Whether the subscription is canceled after the end date */
      subscriptionCancelAfterEnd: boolean;
      /** @description The Discord id */
      discordId?: string | null;
      /** @description The Discord username */
      discordUsername?: string | null;
      /** @description Whether the user is an admin */
      isAdmin: boolean;
      /** @description Whether the user is a findom */
      isFindom: boolean;
      /** @description The user settings */
      settings: components["schemas"]["UserSettings"];
      /** @description The user metadata */
      metadata: components["schemas"]["UserMetadata"];
      /** @description The country */
      country: components["schemas"]["Country"] | null;
      /** @description Region */
      region: components["schemas"]["Region"] | null;
      /** @description Whether the user has accepted the community rules */
      hasAcceptedCommunityRules: boolean;
      /** @description The user id */
      _id: string;
      /** @description The avatar URL */
      avatarUrl: string;
      /** @description True if the user is a premium user */
      isPremium: boolean;
      needsDiscordMigration: boolean;
      privateMetadata: components["schemas"]["UserPrivateMetadataForPublic"];
    };
    CurrentUser: {
      /** @description The gender */
      gender: components["schemas"]["GenderEnum"];
      /** @description The sexual orientation */
      sexualOrientation: components["schemas"]["SexualOrientationEnum"];
      /** @description The role */
      role: components["schemas"]["UserRoleEnum"];
      /** @description Enabled features */
      features: components["schemas"]["FeatureSwitchEnum"][];
      /** @description The user id */
      _id: string;
      /** @description The avatar URL */
      avatarUrl: string;
      /** @description True if the user is a premium user */
      isPremium: boolean;
      needsDiscordMigration: boolean;
      privateMetadata: components["schemas"]["UserPrivateMetadataForPublic"];
      /** @description The user Keycloak id */
      keycloakId: string;
      /** @description The username */
      username: string;
      /** @description The email */
      email: string;
      /**
       * Format: date-time
       * @description End date of subscription
       */
      subscriptionEnd?: string | null;
      /**
       * Format: date-time
       * @description End date of custom subscription
       */
      customSubscriptionEnd?: string | null;
      /** @description Whether the subscription is past due */
      hasPastDueSubscription: boolean;
      /** @description The profile description */
      description: string;
      /** @description The location */
      location: string;
      /**
       * Format: date-time
       * @description The birth date
       */
      birthDate: string | null;
      /** @description Whether the email is verified */
      emailVerified: boolean;
      /** @description Whether the user is a developer */
      isDeveloper: boolean;
      /** @description Whether the user is a moderator */
      isModerator: boolean;
      /** @description Whether the subscription is canceled after the end date */
      subscriptionCancelAfterEnd: boolean;
      /** @description The Discord id */
      discordId?: string | null;
      /** @description The Discord username */
      discordUsername?: string | null;
      /** @description Whether the user is an admin */
      isAdmin: boolean;
      /** @description Whether the user is a findom */
      isFindom: boolean;
      /** @description The user settings */
      settings: components["schemas"]["UserSettings"];
      /** @description The user metadata */
      metadata: components["schemas"]["UserMetadata"];
      /** @description The country */
      country: components["schemas"]["Country"] | null;
      /** @description Region */
      region: components["schemas"]["Region"] | null;
      /** @description Whether the user has accepted the community rules */
      hasAcceptedCommunityRules: boolean;
    };
    SearchUserUsernameDto: {
      search: string;
    };
    SharedLocksCriteriaData: {
      /** @description An array of shared locks ids */
      sharedLockIds?: string[];
      /** @description Whether the request includes locks created by wearers */
      includeKeyholderLocks?: boolean;
    };
    KeyholderSearchLocksCriteria: {
      sharedLocks?: components["schemas"]["SharedLocksCriteriaData"];
    };
    KeyholderSearchLocksDto: {
      /**
       * @description Search criteria
       * @default {}
       */
      criteria?: components["schemas"]["KeyholderSearchLocksCriteria"];
      /**
       * @description Filter by lock status
       * @enum {string}
       */
      status?: "locked" | "unlocked" | "deserted" | "archived";
      /**
       * @description Search by username of shared lock name
       * Min. 2 characters
       */
      search?: string;
      /** @description Page number (starts with 0) */
      page?: number;
      /** @description Number of items returned */
      limit?: number;
    };
    LockForKeyholder: {
      /** @description The status */
      status: components["schemas"]["LockStatusEnum"];
      /**
       * @description Whether the keyholder is unavailable
       * Only available for the wearer
       */
      keyholderUnavailable?: components["schemas"]["KeyholderUnavailableEnum"];
      /**
       * Format: date-time
       * @description The start date
       */
      startDate: string;
      /**
       * Format: date-time
       * @description The minimum initial date configured at creation
       */
      minDate: string;
      /**
       * Format: date-time
       * @description The maximum initial date configured at creation
       */
      maxDate: string;
      /**
       * Format: date-time
       * @description The maximum date of the lock
       *
       * After this date, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDate: string | null;
      /** @description Whether the remaining time is displayed to the wearer */
      displayRemainingTime: boolean;
      /** @description Whether the lock is limited in duration */
      limitLockTime: boolean;
      /**
       * Format: date-time
       * @description Deleted at
       */
      deletedAt: string | null;
      /**
       * Format: date-time
       * @description Unlocked at
       */
      unlockedAt: string | null;
      /**
       * Format: date-time
       * @description Archived at
       */
      archivedAt: string | null;
      /**
       * Format: date-time
       * @description Frozen at
       */
      frozenAt: string | null;
      /**
       * Format: date-time
       * @description Keyholder archived at
       */
      keyholderArchivedAt: string | null;
      /** @description Whether the lock allows session offers */
      allowSessionOffer: boolean;
      /** @description Whether the lock is a test lock and counts in the user stats */
      isTestLock: boolean;
      /** @description The offer token */
      offerToken: string | null;
      /** @description True if the time information should be hidden from the history */
      hideTimeLogs: boolean;
      /** @description Whether the keyholder is trusted */
      trusted: boolean;
      /** @description The lock id */
      _id: string;
      /**
       * Format: date-time
       * @description The end date
       */
      endDate: string | null;
      /** @description The lock title */
      title: string;
      /** @description The total duration, since the creation of the lock */
      totalDuration: number;
      /** @description The user */
      user: components["schemas"]["UserForPublic"];
      /** @description The keyholder */
      keyholder: components["schemas"]["UserForPublic"] | null;
      /** @description The shared lock */
      sharedLock: components["schemas"]["SharedLockForPublic"] | null;
      /** @description Whether the wearer is allowed to view the remaining time */
      isAllowedToViewTime: boolean;
      /** @description Whether the lock can be unlocked */
      canBeUnlocked: boolean;
      /** @description Whether the lock can be unlocked because the max limit date has been reached */
      canBeUnlockedByMaxLimitDate: boolean;
      /** @description Whether the lock is frozen */
      isFrozen: boolean;
      /**
       * @description The user role
       * @enum {string}
       */
      role: "keyholder" | "wearer" | "visitor";
      /** @description The extensions */
      extensions: components["schemas"]["ExtensionPartyForPublic"][];
      /** @description The combination */
      combination: string;
      /**
       * @description List of home actions
       * Only available for the wearer
       */
      availableHomeActions?: components["schemas"]["ExtensionHomeActionWithPartyId"][];
      /** @description Reasons preventing unlocking */
      reasonsPreventingUnlocking: components["schemas"]["ReasonPreventingUnlocking"][];
      /** @description Whether the extensions allow unlocking */
      extensionsAllowUnlocking: boolean;
      /** @description The last verification picture */
      lastVerificationPicture: components["schemas"]["VerificationPictureItem"] | null;
      /**
       * Format: date-time
       * @description Created at
       */
      createdAt: string;
      /**
       * Format: date-time
       * @description Updated at
       */
      updatedAt: string;
    };
    KeyholderSearchLocksRepDto: {
      /** @description Number of pages */
      pages: number;
      /** @description Number of results */
      total: number;
      /** @description List of locks */
      locks: components["schemas"]["LockForKeyholder"][];
    };
    CreateSharedLockPartnerConfigurationRepDto: {
      /** @description The partner configuration token */
      token: string;
    };
    CreatePartnerConfigurationRepDto: {
      /** @description The partner configuration token */
      token: string;
    };
    /** @enum {string} */
    PeerVerificationStatusEnum: "ongoing" | "verified" | "rejected";
    PeerVerificationVoteStatus: {
      /** @description Peer verification status */
      status: components["schemas"]["PeerVerificationStatusEnum"];
      /** @description Peer verification id */
      _id: string;
      /** @description Number of verified votes */
      verifiedVotes: number;
      /** @description Number of rejected votes */
      rejectedVotes: number;
    };
    VerificationPictureHistoryEntry: {
      /** @description The verification code */
      verificationCode: string | null;
      /** @description The peer verification id */
      peerVerificationId: string | null;
      /** @description The peer verification image key */
      imageKey: string;
      /**
       * Format: date-time
       * @description Submitted at
       */
      submittedAt: string;
      /** @description Votes if the peer verification is enabled */
      votes: components["schemas"]["PeerVerificationVoteStatus"] | null;
    };
    CreateUpdateSharedLockDto: {
      /** @description The minimum duration, in seconds */
      minDuration: number;
      /** @description The maximum duration, in seconds */
      maxDuration: number;
      /**
       * @description The maximum duration of the lock, in seconds
       *
       * After this duration, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDuration: number | null;
      /**
       * Format: date-time
       * @description The minimum date
       */
      minDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date
       */
      maxDate: string | null;
      /**
       * Format: date-time
       * @description The maximum date of the lock
       *
       * After this date, the wearer can release themself
       * regardless of the timer or extension restrictions.
       */
      maxLimitDate: string | null;
      /** @description Whether the remaining time should be displayed to the wearer */
      displayRemainingTime: boolean;
      /** @description Whether the lock is limited in time */
      limitLockTime: boolean;
      /** @description Whether the lock is public */
      isPublic: boolean;
      /** @description The number of maximum locked users for this shared lock */
      maxLockedUsers: number | null;
      /** @description An optional password */
      password: string | null;
      /**
       * @description Whether the shared lock requires contact from wearer
       *
       * Displayed for information purposes only on the lock page
       */
      requireContact: boolean;
      /** @description The name */
      name: string;
      /** @description The description */
      description: string;
      /** @description The Unsplash photo id */
      photoId: string;
      /** @description Whether the time information should be hidden from the history */
      hideTimeLogs: boolean;
      /**
       * @description Whether the lock is a findom lock
       * @default false
       */
      isFindom: boolean;
      /** @description Tags */
      tags?: string[];
    };
    CreateSharedLockRepDto: {
      /** @description The created shared lock id */
      id: string;
    };
    SharedLockTagForPublic: {
      name: string;
    };
    FindSuggestedTagDto: {
      /** @description The text */
      text: string;
    };
    IsFavoriteSharedLockRepDto: {
      /** @description Whether the lock is user favorite */
      favorite: boolean;
    };
    GetFavoriteSharedLocksDto: {
      /** @default 15 */
      limit: number;
      lastId?: string;
    };
    GetFavoriteSharedLocksRepDto: {
      results: components["schemas"]["PublicLockForSearch"][];
      lastId: string;
      hasMore: boolean;
      count: number;
    };
    KeycloakGlobalConfig: {
      clientId: string;
      realm: string;
      url: string;
    };
    GlobalConfig: {
      apiUrl: string;
      keycloak: components["schemas"]["KeycloakGlobalConfig"] | null;
    };
    /** @enum {string} */
    PartnerConfigurationChildEventEnum: "capabilities" | "save_loading" | "save_success" | "save_failed";
    PartnerConfigurationChildCapabilitiesFeatures: {
      save: boolean;
    };
    PartnerConfigurationChildCapabilitiesEvent: {
      features: components["schemas"]["PartnerConfigurationChildCapabilitiesFeatures"];
    };
    PartnerConfigurationChildEvents: {
      event: components["schemas"]["PartnerConfigurationChildEventEnum"];
      payload: components["schemas"]["PartnerConfigurationChildCapabilitiesEvent"];
    };
    ExtensionSessionCreatedExtension: {
      slug: string;
    };
    ExtensionSessionCreatedData: {
      session: components["schemas"]["ExtensionSessionForPartner"];
      extension: components["schemas"]["ExtensionSessionCreatedExtension"];
    };
    ExtensionSessionCreated: {
      /** @enum {string} */
      event: "extension_session.created";
      data: components["schemas"]["ExtensionSessionCreatedData"];
      /** Format: date-time */
      sentAt: string;
      requestId: string;
    };
    ExtensionSessionUpdatedExtension: {
      slug: string;
    };
    ExtensionSessionUpdatedData: {
      session: components["schemas"]["ExtensionSessionForPartner"];
      extension: components["schemas"]["ExtensionSessionUpdatedExtension"];
    };
    ExtensionSessionUpdated: {
      /** @enum {string} */
      event: "extension_session.updated";
      data: components["schemas"]["ExtensionSessionUpdatedData"];
      /** Format: date-time */
      sentAt: string;
      requestId: string;
    };
    ExtensionSessionCreatedDataSession: {
      sessionId: string;
      lock: components["schemas"]["LockForPublic"];
    };
    ExtensionSessionDeletedExtension: {
      slug: string;
    };
    ExtensionSessionDeletedData: {
      session: components["schemas"]["ExtensionSessionCreatedDataSession"];
      extension: components["schemas"]["ExtensionSessionDeletedExtension"];
    };
    ExtensionSessionDeleted: {
      /** @enum {string} */
      event: "extension_session.deleted";
      data: components["schemas"]["ExtensionSessionDeletedData"];
      /** Format: date-time */
      sentAt: string;
      requestId: string;
    };
    ActionLogCreatedData: {
      /** @description The session id */
      sessionId: string;
      /** @description The action log */
      actionLog: components["schemas"]["ActionLogForPublic"];
    };
    ActionLogCreated: {
      /** @enum {string} */
      event: "action_log.created";
      data: components["schemas"]["ActionLogCreatedData"];
      /** Format: date-time */
      sentAt: string;
      requestId: string;
    };
    WebhookEventForPublic: {
      payload: components["schemas"]["ExtensionSessionCreated"] | components["schemas"]["ExtensionSessionUpdated"] | components["schemas"]["ExtensionSessionDeleted"] | components["schemas"]["ActionLogCreated"];
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /**
   * Upload attachments
   * @description Upload attachments and get an attachment token to be used in messaging and posts
   *
   * The attachment token expires after one hour.
   */
  StorageController_uploadFiles: {
    requestBody: {
      content: {
        "multipart/form-data": components["schemas"]["UploadFilesDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["UploadFilesRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Find a file */
  StorageController_getFileFromKey: {
    parameters: {
      path: {
        /** @description The file key */
        fileKey: string;
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["GetFileFromKeyRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a report
   * @description Create a report
   */
  ReportCreationController_createReport: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateReportDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Find all user shared locks
   * @deprecated
   * @description Use GET /shared-locks instead
   */
  LegacySharedLockController_DEPRECATED_findAll: {
    parameters: {
      query?: {
        /** @description The shared lock status */
        status?: "active" | "archived";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedLockForPublic"][];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a shared lock
   * @deprecated
   * @description Use POST /shared-locks
   */
  SharedLockController_DEPRECATED_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUpdateSharedLockDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CreateSharedLockRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Find a shared lock by id
   * @deprecated
   * @description Use GET /shared-locks/:sharedLockId instead
   */
  LegacySharedLockController_DEPRECATED_findOne: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedLockForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update a shared lock
   * @deprecated
   * @description Use PUT /shared-locks/:sharedLockId
   */
  SharedLockController_DEPRECATED_update: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUpdateSharedLockDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Archive a shared lock
   * @deprecated
   * @description Use PATCH /shared-locks/:sharedLockId/archive instead
   */
  LegacySharedLockController_DEPRECATED_archive: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      201: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get user locks
   * @description Returns a list of all user locks
   *
   * By default, only active locks are returned.
   */
  LockController_findAll: {
    parameters: {
      query?: {
        /** @description The lock status */
        status?: "active" | "archived" | "all";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["LockForPublic"][];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a lock
   * @description Creates a personal lock. To create a lock, you must first create
   * a combination by using the combination endpoints, and then provide its identifier.
   */
  LockCreationController_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateLockDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["LockCreatedRepDto"];
        };
      };
      /** @description You must be a Plus member to add more extensions */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Get a lock by id
   * @description Returns a lock by id
   */
  LockController_findOne: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["LockForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Archive a lock
   * @description Archives a lock as a wearer. A wearer can archive its own lock:
   * <ul>
   * <li>If the lock is running (status `locked`), the lock will become deserted (status `deserted`),
   * with no possibility of going back.</li>
   * <li>If the lock is unlocked, the lock will simply be archived.</li>
   * </ul>
   */
  LockController_archive: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Cannot archive the lock as a non-wearer */
      403: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Archive a lock as a keyholder
   * @description Archives a lock as a keyholder. Keyholders can use this endpoint to archive unlocked locks.
   */
  LockController_archiveKeyholder: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Cannot archive the lock as a non-keyholder */
      403: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update lock duration
   * @description Adds or removes duration to a lock. Keyholders can add or remove time, while wearers can only add time.
   */
  LockController_updateTime: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateTimeDto"];
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Cannot change an non-locked lock */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Freeze a lock
   * @description Freezes a lock. Keyholders can use this endpoint to freeze wearer's locks.
   */
  LockController_setFreeze: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetFreezeDto"];
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Cannot change an non-locked lock */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description The lock cannot be edited (wearer) */
      403: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Unlock a lock
   * @description Unlocks a lock. For wearers, the lock must respect certain constraints so that it can be unlocked.
   */
  LockController_unlock: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Some extensions prevent the unlocking of the lock */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Convert a lock to a self lock
   * @description Converts a lock to a self lock. Only the wearer can convert a lock to a self lock.
   */
  LockController_convertToSelfLock: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
      /** @description Only wearers can convert to self lock, Keyholder is available, cannot convert to self lock */
      422: {
        content: never;
      };
    };
  };
  /**
   * Update lock settings
   * @description Update locks settings. Only the keyholder can update lock settings.
   */
  LockController_setSettings: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetLockSettingsDto"];
      };
    };
    responses: {
      204: {
        content: never;
      };
      /** @description Cannot change an non-locked lock */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description The lock cannot be edited (wearer) */
      403: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Increase the max limit date
   * @description Increase the max limit date. Only the wearer can increase the limit.
   */
  LockController_setMaxLimitDate: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["IncreaseMaxLimitDateDto"];
      };
    };
    responses: {
      204: {
        content: never;
      };
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description The lock cannot be edited (keyholder) */
      403: {
        content: never;
      };
    };
  };
  /**
   * Trust the keyholder
   * @description Trust the keyholder. Only the wearer can trust the keyholder.
   */
  LockController_trustKeyholder: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      204: {
        content: never;
      };
      400: {
        content: {
          "application/json": unknown;
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description The lock cannot be edited (keyholder) */
      403: {
        content: never;
      };
    };
  };
  /**
   * Find a lock combination
   * @description Finds a lock combination
   */
  LockController_combination: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CombinationForPublic"];
        };
      };
      /** @description Cannot get a combination for a locked lock */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Return lock history
   * @description Returns a list of action logs
   */
  LockController_getLockHistory: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetLockHistoryDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["GetHistoryRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Set an archived lock as a test lock
   * @description Set an archived lock as a test lock
   */
  LockController_setAsTestLock: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
      /** @description Only wearers can set locks as test locks */
      422: {
        content: never;
      };
    };
  };
  /**
   * Return the public locks of a user
   * @description Returns the public locks of a user
   */
  LockVisitorController_getUserLocks: {
    parameters: {
      path: {
        userId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["LockForPublic"][];
        };
      };
    };
  };
  /**
   * Upload a combination image
   * @description Uploads an image and stores the combination. Once the image is uploaded,
   * it cannot be recovered without being associated with a lock. To retrieve
   * the combination, refer to the endpoint `/locks/{lockId}/combination` to
   * get the image URL.
   *
   * If the combination is not associated with a lock, it expires after one hour.
   */
  CombinationController_uploadImage: {
    requestBody: {
      content: {
        "multipart/form-data": components["schemas"]["UploadCombinationImageDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CreateCodeRepDto"];
        };
      };
      /** @description The user is not a Premium user */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a code combination
   * @description Creates and stores the code combination. Once the code is sent, it cannot
   * be recovered without being associated with a lock. To retrieve the
   * combination, refer to the endpoint `/locks/{lockId}/combination` to get
   * the code.
   *
   * If the combination is not associated with a lock, it expires after one hour.
   */
  CombinationController_createCode: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateCodeDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CreateCodeRepDto"];
        };
      };
    };
  };
  /** Find a user by id */
  ProfileController_getUserById: {
    parameters: {
      path: {
        /** @description The user id */
        userId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserForPublic"];
        };
      };
      /** @description User not found */
      404: {
        content: never;
      };
    };
  };
  /** Find a user profile */
  ProfileController_getUser: {
    parameters: {
      path: {
        /** @description The username */
        username: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserForPublic"];
        };
      };
      /** @description User not found */
      404: {
        content: never;
      };
    };
  };
  /** Find a user profile with details */
  ProfileController_getUserProfile: {
    parameters: {
      path: {
        /** @description The username */
        username: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ProfileRepDto"];
        };
      };
      /** @description User not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Get the list of extensions
   * @description Returns the list of all extensions in memory
   */
  ExtensionListController_getExtensions: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ExtensionForPublic"][];
        };
      };
    };
  };
  /**
   * Find a public shared lock
   * @description Finds a public shared lock
   */
  PublicLockController_findOne: {
    parameters: {
      path: {
        sharedLockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PublicLockForPublic"];
        };
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Generate a shared lock image
   * @description Generates an image illustrating the shared lock, to publish it on forums or social networks.
   */
  PublicLockController_getSharedLockImage: {
    parameters: {
      path: {
        sharedLockId: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Search for locks
   * @description Search for locks
   */
  PublicLockController_search: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchPublicLockDto"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SearchPublicLockRepDto"];
        };
      };
    };
  };
  /**
   * Find Explore page locks
   * @description Returns the locks of the Explore page
   */
  PublicLockExploreController_findAll: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ExploreCategoryForPublic"][];
        };
      };
    };
  };
  /**
   * Find blocked users
   * @description Find blocked users
   */
  BlockController_findBlocks: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["FindBlocksRepDto"];
        };
      };
    };
  };
  /**
   * Block user
   * @description Block user
   */
  BlockController_blockUser: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["BlockUserDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Find block interaction with another user
   * @description Find block interaction with another user
   */
  BlockController_getBlockInteraction: {
    parameters: {
      path: {
        /** @description The target user id */
        targetUserId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["BlockInteraction"];
        };
      };
    };
  };
  /**
   * Unblock user
   * @description Unblock user
   */
  BlockController_unblockUser: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["UnblockUserDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Create a keyholding offer
   * @description Allows the wearer to send a keyholding request to another user.
   */
  SessionOfferController_createKeyholdingOffer: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateOfferRequestDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
      /** @description You cannot be your own keyholder. */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Accept a keyholding request
   * @description Accepts a keyholding request from a wearer. By accepting the request, you will become the keyholder. The `offerToken` parameter can be found in the `LockForPublic` object, if the user has enabled this option when creating the lock.
   */
  SessionOfferController_acceptKeyholdingRequest: {
    parameters: {
      path: {
        /** @description The lock offer token */
        offerToken: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description You cannot be your own keyholder. */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Return a list of keyholding offers
   * @description Returns a list of keyholding offers
   */
  SessionOfferController_getOfferRequestStatus: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SessionOfferRequestForPublic"][];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Retrive public information of a lock
   * @description Retrieves public information of the lock for the visitor who received a keyholding request link
   */
  SessionOfferController_getLockKeyholdingRequest: {
    parameters: {
      path: {
        /** @description The keyholding request token */
        offerToken: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["LockForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Accept or reject a keyholding offer from a wearer
   * @description Accepts or reject a keyholding offer sent directly by a wearer
   */
  SessionOfferController_validateOfferRequest: {
    parameters: {
      path: {
        /** @description The keyholding offer id */
        sessionRequestId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ValidateOfferRequestDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session offer request not found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * Archive a keyholding offer
   * @description Archives a keyholding offer. If the offer is pending, it cancels the keyholding offer.
   */
  SessionOfferController_archiveKeyholdingOffer: {
    parameters: {
      path: {
        /** @description The keyholding offer id */
        sessionRequestId: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session offer request not found. */
      404: {
        content: never;
      };
    };
  };
  /**
   * Return keyholding offers from wearers
   * @description Returns keyholding offers from wearers
   */
  SessionOfferController_getKeyholderRequests: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SessionOfferRequestForKeyholder"][];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Get the user badge count
   * @description Returns the user badge count
   */
  UserBadgeController_getUserBadgeCount: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserBadgeCount"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Find a list of conversations
   * @description Finds a list of conversations
   */
  MessagingController_getConversations: {
    parameters: {
      query?: {
        /** @description The query limit */
        limit?: number;
        /** @description The conversation status */
        status?: "pending" | "approved" | "ignored";
        /**
         * @description The query offset, date of last message
         *
         * Use the field lastMessageAt for pagination
         */
        offset?: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GetConversationsRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a conversation
   * @description Creates a conversation
   */
  MessagingController_createConversation: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateConversationDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["ConversationForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Find conversation by user id
   * @description Finds a conversation by user id
   */
  MessagingController_getConversationByUserId: {
    parameters: {
      path: {
        /** @description The user id */
        userId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ConversationForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Find a conversation
   * @description Finds a conversation
   */
  MessagingController_getConversation: {
    parameters: {
      path: {
        /** @description The conversation id */
        conversationId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["ConversationForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Add a new message to a conversation
   * @description Updates a conversation
   */
  MessagingController_sendMessage: {
    parameters: {
      path: {
        /** @description The conversation id */
        conversationId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdateConversationDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["MessageForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Set a conversation status
   * @description Updates a conversation status
   */
  MessagingController_setConversationStatus: {
    parameters: {
      path: {
        /** @description The conversation id */
        conversationId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetConversationStatusDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Set a conversation unread status
   * @description Updates a conversation unread status
   */
  MessagingController_setConversationUnread: {
    parameters: {
      path: {
        /** @description The conversation id */
        conversationId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetConversationUnreadDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Find messages in a conversation
   * @description Finds messages in a conversation
   */
  MessagingController_getMessages: {
    parameters: {
      query?: {
        /** @description The query limit */
        limit?: number;
        /** @description Last message id */
        lastId?: string;
      };
      path: {
        /** @description The conversation id */
        conversationId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GetMessagesRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  IgnoredUserController_findIgnoredUsers: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["IgnoredUsersRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Get information from an extension for a given lock */
  LockExtensionController_getLockInfoFromExtension: {
    parameters: {
      path: {
        extensionId: string;
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GetLockInfoFromExtensionRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Trigger an action for a lock extension
   * @description Triggers an action in a lock extension
   */
  LockExtensionController_triggerAction: {
    parameters: {
      path: {
        /** @description The extension party id */
        extensionId: string;
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TriggerExtensionActionDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": Record<string, never>;
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Get a lock combination
   * @description Returns the lock combination
   *
   * This endpoint only works if the lock is temporarily unlocked by the temporary opening extension
   */
  TemporaryOpeningExtensionController_getCombination: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CombinationForPublic"];
        };
      };
    };
  };
  /**
   * Set the new combination
   * @description Updates the lock combination
   *
   * This endpoint only works if the lock is temporarily unlocked by the temporary opening extension
   */
  TemporaryOpeningExtensionController_setCombination: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TemporaryOpeningSetCombinationDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  /**
   * Find a combination from an action log
   * @description Finds a lock combination from a previous temporary opening
   */
  TemporaryOpeningExtensionController_getCombinationFromHistoryEntry: {
    parameters: {
      path: {
        /** @description The action log id */
        actionLogId: string;
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CombinationForPublic"];
        };
      };
    };
  };
  /** Get community event categories */
  CommunityEventController_getCategories: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CommunityEventCategory"][];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Get community event task details for a given day */
  CommunityEventController_getPeriodDetails: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetPeriodDetailsDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["GetPeriodDetailsRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Edit lock extensions
   * @description Edit extensions for a given lock.
   *
   * Keyholders can edit extensions if the lock is trusted by the wearer.
   */
  LockCreationController_setLockExtensions: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["EditLockExtensionsDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a lock from a shared lock
   * @description Creates a lock from a shared lock. To create a lock, you must first
   * create a combination and then provide its identifier.
   */
  LockCreationController_createLockFromSharedLock: {
    parameters: {
      path: {
        /** @description Shared lock id */
        sharedLockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateLockFromSharedLockDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["LockCreatedRepDto"];
        };
      };
      /** @description You cannot add yourself to your own lock. */
      400: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Invalid password. */
      403: {
        content: never;
      };
      /** @description Shared lock not found. */
      404: {
        content: never;
      };
    };
  };
  /** Return a list of extensions */
  PartnerExtensionController_findAll: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PartnerExtensionForDashboard"][];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Create an extension */
  PartnerExtensionController_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreatePartnerExtensionDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["PartnerExtensionForDashboard"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Find an extension */
  PartnerExtensionController_findOne: {
    parameters: {
      path: {
        /** @description The extension id */
        extensionId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PartnerExtensionForDashboard"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Extension not found */
      404: {
        content: never;
      };
    };
  };
  /** Update an extension */
  PartnerExtensionController_update: {
    parameters: {
      path: {
        /** @description The extension id */
        extensionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePartnerExtensionDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Extension not found */
      404: {
        content: never;
      };
    };
  };
  /** Delete an extension */
  PartnerExtensionController_delete: {
    parameters: {
      path: {
        /** @description The extension id */
        extensionId: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Extension not found */
      404: {
        content: never;
      };
    };
  };
  /** Retrieve information from an extension lock session */
  PartnerActionsController_getExtensionSession: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GetPartnerSessionRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update partial information for an extension lock session
   * @description Update partial information for an extension lock session. All fields are optional.
   * If you provide a value for a field, the content of the whole field is replaced.
   * For example, if you provide a `config` object, the whole object is replaced by
   * the payload received. If you only need to update one field in your object, make
   * sure to send the whole object back.
   * If you don't provide a field, it will be unchanged.
   */
  PartnerActionsController_patchExtensionSession: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PatchExtensionSessionDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /** Run an action on the lock */
  PartnerActionsController_doAction: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PartnerDoActionDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /** List log entries for an extension lock session */
  PartnerActionsController_getLogs: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetPartnerLogsDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["GetHistoryRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update metadata for an extension lock session
   * @deprecated
   * @description Deprecated, please use PATCH /api/extensions/sessions/{sessionId}
   */
  PartnerActionsController_setMetadata: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PartnerSetMetadataDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Search for extension sessions
   * @description Search for extension sessions
   */
  PartnerSessionController_getSessions: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetSessionsDto"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GetSessionsRepDto"];
        };
      };
    };
  };
  /** Get submitted regular actions */
  SessionRegularActionController_getRegularActions: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["GetRegularActionsRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /** Submit a regular action on the lock */
  SessionRegularActionController_submitRegularAction: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SubmitRegularActionDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["GetRegularActionsRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
      /** @description You cannot submit a regular action because you do not have any action remaining. Please wait for the next regular action date and try again. */
      422: {
        content: {
          "application/json": components["schemas"]["SubmitRegularActionErrorDto"];
        };
      };
    };
  };
  /** Create a custom log entry for an extension lock session */
  PartnerLogController_logCustomAction: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["PartnerCustomLogActionDto"];
      };
    };
    responses: {
      201: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Set session custom data
   * @deprecated
   * @description Deprecated, please use PATCH /api/extensions/sessions/{sessionId}
   */
  SessionDataController_setData: {
    parameters: {
      path: {
        /** @description The session id */
        sessionId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["SetSessionDataDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Retrieve the extension configuration from a configuration token.
   *
   *       The configuration token is passed in hash parameters of your configuration page.
   */
  PartnerConfigurationController_getConfiguration: {
    parameters: {
      path: {
        /** @description The configuration token */
        token: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PartnerConfigurationForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Configuration not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update the extension configuration from a configuration token.
   *
   *       The configuration token is passed in hash parameters of your configuration page.
   */
  PartnerConfigurationController_updateConfiguration: {
    parameters: {
      path: {
        /** @description The configuration token */
        token: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["UpdatePartnerConfigurationDto"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PartnerConfigurationForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Configuration not found */
      404: {
        content: never;
      };
    };
  };
  /** Get app settings */
  SettingsController_getAppSettings: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["AppSettingsDto"];
        };
      };
    };
  };
  /** Get a session authorization */
  PartnerMainAuthorizationController_getSessionAuth: {
    parameters: {
      header: {
        /** @description The application client id */
        "X-Chaster-Client-Id": string;
      };
      path: {
        /** @description The token passed in parameters of the main page */
        token: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["PartnerGetSessionAuthRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Session not found */
      404: {
        content: never;
      };
    };
  };
  /** Update profile from the authentication server */
  AuthMeController_getUpdatedProfile: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CurrentUserForProfileSettings"];
        };
      };
    };
  };
  /** Get logged user information */
  AuthMeController_me: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["CurrentUser"];
        };
      };
    };
  };
  /** Search a user by its username */
  UserSearchController_searchByUsername: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["SearchUserUsernameDto"];
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserForPublic"][];
        };
      };
    };
  };
  /** Search a user by its Discord id */
  UserSearchController_getUserByDiscordId: {
    parameters: {
      path: {
        /** @description The user Discord id */
        discordId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["UserForPublic"];
        };
      };
      /** @description User not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Search locked users
   * @description Search locked users
   */
  KeyholderController_searchLocks: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["KeyholderSearchLocksDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["KeyholderSearchLocksRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Create a partner configuration from a shared lock extension configuration */
  PartnerConfigurationCreationController_createSharedLockPartnerConfiguration: {
    parameters: {
      path: {
        /** @description The partner extension id */
        partnerExtensionId: string;
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CreateSharedLockPartnerConfigurationRepDto"];
        };
      };
    };
  };
  /** Create a partner configuration from a lock extension configuration */
  PartnerConfigurationCreationController_createLockPartnerConfiguration: {
    parameters: {
      path: {
        /** @description The partner extension id */
        partnerExtensionId: string;
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CreateSharedLockPartnerConfigurationRepDto"];
        };
      };
    };
  };
  /** Create a partner configuration with the default configuration */
  PartnerConfigurationCreationController_createPartnerConfiguration: {
    parameters: {
      path: {
        /** @description The partner extension id */
        partnerExtensionId: string;
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CreatePartnerConfigurationRepDto"];
        };
      };
    };
  };
  /**
   * Submit a verification picture
   * @description Uploads a new verification picture
   *
   * A user can upload a picture only if there is an existing request.
   */
  VerificationPictureController_submitPicture: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      201: {
        content: never;
      };
    };
  };
  /** Get the history of verification pictures */
  VerificationPictureController_getVerificationPictures: {
    parameters: {
      path: {
        /** @description The lock id */
        lockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["VerificationPictureHistoryEntry"][];
        };
      };
    };
  };
  /**
   * Find all user shared locks
   * @description Returns a list of all user shared locks
   */
  SharedLockController_findAll: {
    parameters: {
      query?: {
        /** @description The shared lock status */
        status?: "active" | "archived";
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedLockForPublic"][];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Create a shared lock
   * @description Creates a shared lock
   */
  SharedLockController_create: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUpdateSharedLockDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["CreateSharedLockRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /**
   * Find a shared lock by id
   * @description Finds a shared lock by id
   */
  SharedLockController_findOne: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedLockForPublic"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Update a shared lock
   * @description Updates a shared lock
   */
  SharedLockController_update: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateUpdateSharedLockDto"];
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /**
   * Archive a shared lock
   * @description Archives a shared lock
   */
  SharedLockController_archive: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      201: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
      /** @description Shared lock not found */
      404: {
        content: never;
      };
    };
  };
  /** Find all shared lock tags */
  SharedLockTagController_findAllTags: {
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["SharedLockTagForPublic"][];
        };
      };
    };
  };
  /** Find suggested shared lock tags */
  SharedLockTagController_findSuggestedTags: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["FindSuggestedTagDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["SharedLockTagForPublic"][];
        };
      };
    };
  };
  /** Check if the shared lock is in user favorites */
  SharedLockFavoriteController_isFavorite: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      200: {
        content: {
          "application/json": components["schemas"]["IsFavoriteSharedLockRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Set a shared lock as favorite */
  SharedLockFavoriteController_setFavorite: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Remove a favorite shared lock */
  SharedLockFavoriteController_removeFavorite: {
    parameters: {
      path: {
        /** @description The shared lock id */
        sharedLockId: string;
      };
    };
    responses: {
      200: {
        content: never;
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
  /** Get user favorite shared locks */
  SharedLockFavoritesController_getFavoriteSharedLocks: {
    requestBody: {
      content: {
        "application/json": components["schemas"]["GetFavoriteSharedLocksDto"];
      };
    };
    responses: {
      201: {
        content: {
          "application/json": components["schemas"]["GetFavoriteSharedLocksRepDto"];
        };
      };
      /** @description Not authorized */
      401: {
        content: never;
      };
    };
  };
}
